---
layout:     post   				    # 使用的布局（不需要改）
title:      面试常问到的知识点总结 				# 标题 
subtitle:   这是我在牛客网上学习到的一点面试知识点，非常实用 #副标题
date:       2020-04-02-面试知识点总结 				# 时间
author:     BY 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 计算机基础
---
# 介绍
这一阵参加春招，面了很多公司，虽然最后有心仪的offer，但还是感到自己有很多的不足，在牛客网上有非常丰富的面试资料，这是我自己总结与思考的一点内容
我最近有点懒，没有好好排版，大家可以凑合着看~

# 第一章 基础知识
## 第一节
### 1. static关键字的作用
static是静态关键字，有三种使用情况
    静态变量
        全局静态变量：
            1. 变量存放在静态存储区
            2. 未初始化就为0
            3. 全局作用域：从定义处到文件的结尾
        局部静态变量
            1. 变量存放在静态存储区
            2. 未初始化就为0
            3. 局部作用域：当离开作用域时，不会被销毁，而是驻留在内存当中，数值保持，直到下一次调用该部分
    静态函数
        若是不加static，默认函数都是externa的
        静态函数只能在声明的文件（1.cpp）中使用，不能被其他文件使用，目的是不会与其他cpp中的同名函数引起冲突
        **头文件中的函数不能定义成静态类型，在cpp内都使用静态函数，当多个cpp内需要函数复用，就提到头文件中去**

    类的静态成员（静态数据成员）
        类的静态成员可以实现多个对象之间的数据共享，静态成员是类的所有对象共享的，存储一处，供所有对象共用
    
    类的静态函数（静态函数成员）
        静态函数也是静态成员
        1.(静态成员的引用不需要对象名，只需要类名)
        2.？？(静态成员函数不能直接引用类中的非静态成员，要通过对象引用)
        3.静态成员函数的调用：<类名>::<静态成员函数名>

全局变量static修改链接属性，不改变作用域与存储类型
局部变量static修改存储类型，不改变连接属性与作用域

补充：内存大体上分为三个部分，
    1. 静态存储区：在程序运行期间都存在，用于存放静态数据，全局数据与常量
    2. 栈区：局部变量在栈内创建，函数执行结束被释放
    3. 堆区（动态内存分配）：用malloc或者new申请内存，使用free或者delete释放内存，动态的生存期由我们决定，**好习惯是当不再使用动态内存时应当释放，否则会内存泄露**

### 2. C++和C的区别
1. 设计思想
    一个是面向对象，一个是面向过程
2. 语法
    C++有封装，继承，多态三种特性
    C++有类型安全，比如强制类型转换
    C++支持范式编程，比如模板类，函数模板

封装：将抽象的数据与对数据的操作封装在一起，只有通过成员方法（操作）才能够对数据进行操作

继承：子类可以继承父类的属性与方法，不需要重新定义，继承也可以重载与覆盖父类函数

声明方式：class 子类 extends 父类

多态：同一个操作对于不同对象，有不同的解释，产生不同的执行结果，通过指向父类的指针，调用在不同子类中实现的方法。

函数模板是定义大概功能，具体执行根据实际参数决定功能，比如一个比较两数大小的函数，两数可以是整数，浮点数，字符等等，要根据输入决定其功能

类模板也是大概的意思，有一批类，只有成员数据类型不同，抽象出一个模板，在执行过程中生成具体的类

### 3. ？？四种cast转换（类型转换）
const_cast：将const转换为非const

static_cast：用于隐式转换，可以多态向上转换

dynamic_cast：

reinterpret_cast：

隐式转换：根据程序需要自动转换
char - int - long - double
float - double
    例如：
    int m = 10;
    double n = m;

显式转换：也叫强制转换，是主动转换
    例如：
    int m = 5;
    char c = (char)m;

### 4. C++中指针与引用的区别
1. 指针有自己的一块空间，引用只是个别名
2. sizeof看指针的大小是4，引用则是被引用对象的大小
3. 指针初始化可以为null，引用必须初始化为一个已有对象
4. 指针需要解引用才能够操作对象，而引用可直接修改对象
5. 有const指针，但没有const引用
6. 指针可以指向其他对象，引用只能是一个对象的引用
8. 指针++与引用++的涵义不同
9. 动态内存分配的对象返回必须用指针，引用可能导致内存泄露

**总而言之，程序为指针分配内存区域，而引用只是别名，**

引用的声明：类型标识符 &引用名=目标变量名

### 5. 野指针
指向一个已经删除的对象，或者指向未申请访问受限内存区域的指针，对野指针的操作比较危险

内存泄露：动态分配 的堆内存由于某种原因未释放或者无法释放，使得系统内存浪费

### 6. 数组与指针的区别
1. 指针是保存数据的地址，数组用于保存数据
2. 指针间接访问数据，先获得指针内存再寻址找到数据，而数组直接访问数据
3. 指针用于动态的数据结构malloc，数组用于固定数目的元素
4. 指针能动态分配与释放内存，数组隐式分配
5. 指针指向匿名数据与匿名函数，数组自身就是数据名

### 7. 智能指针
指针非常危险，使用不当会有内存泄漏的问题，智能指针更好操作，能避免一些情况下的内存泄漏问题。

智能原理：管理指针，当声明一个指针指向malloc创建的空间时，防止动态申请的内存空间忘记释放，造成内存泄漏。
实现方式：是将指针作为一个类，当超过作用域时会自动调用析构函数释放资源，不需要手动释放内存空间。

auto_ptr：（C++11已经舍弃了）
    auto_ptr<string> p1 (new string ("I reigned lonely as a cloud.”));
    auto_ptr<string> p2;
    p2 = p1; //auto_ptr不会报错.
    
    p2剥夺了p1的所有权，程序运行时访问p1就会报错，所以存在内存崩溃问题。

unique_ptr：
    unique_ptr<string> p3 (new string ("auto");
    unique_ptr<string> p4；
    p4 = p3;//此时会报错！！

    实现独占式拥有，同一时刻只能有一个智能指针指向对象，非常有用，就避免了上面潜在出现的内存崩溃

shared_ptr：
    实现共享式拥有，同一个对象可以有多个智能指针，而对象在最后一个引用销毁时释放空间资源。通过计数机制表明被几个指针共享，通过use_count()查看资源所有者个数
    有这几个成员函数：
        use_count：返回指针个数
        unique：返回是否独占所有权
        swap：交换两个指针指向的对象
        reset：放弃对对象的所有权，会导致对象的计数减少
        get：返回内部对象（不太明白）
weak_ptr：
    作用是解决shared_ptr相互引用时造成死锁问题，如果有两个shared相互引用，引用计数不能下降为0，资源不会被释放，weak是种弱引用，不会增加引用计数。当有一个shared和一个weak就不会出现死锁。**注意weak不能直接访问对象，而是转换为shared再访问**

总结：指针指针用于管理堆上分配的内存，会将指针封装为一个栈对象，生存周期结束时通过析构函数释放申请的内存，防止内存的泄漏。

最常用的智能指针是shared_ptr，不能直接将普通指针直接赋值给智能指针，而通过make_sahred()函数或者构造函数传入普通指针。

### 8. 智能指针的内存泄漏
当两个对象相互使用一个shared指向对方，会有循环引用，引用计数失效导致内存泄漏。
跟死锁一个道理，都是成了环，到了要结束时无法清零，但是不用记环，最基础的是两个对象相互引用，形成死锁

解决方式：引入weak_ptr，一个shared，一个weak就不会形成死锁

### 9. 函数指针
定义：函数指针本身是个指针变量，指向一个函数，每个函数在编译时有一个入口地址，该地址就是函数指针指向的地址，可以用该指针变量调用函数。

用处：可以用函数指针调用函数，相当于通过函数名调用函数，优点是可以做函数的参数，形成回调函数

语法：通过函数指针调用函数
    char * fun(char * p)  {…}// 函数fun
    char * (*pf)(char * p);  // 函数指针pf
    pf = fun;  // 函数指针pf指向函数fun
    pf(p);     // 通过函数指针pf调用函数fun

### 10. 析构函数与虚函数
虚函数是用来实现多态的，定义在基类当中，没有具体实现，而子类必须实现覆盖

1. 将可能变成的父类的析构函数设置为虚函数
2. 而默认的析构函数不是虚函数

1. 当new一个子类，调用基类指针可以释放掉子类的空间，防止内存泄漏，但是如果使用父类的析构函数，没法释放子类占用的空间。

2. 虚函数需要额外的虚函数表和虚表指针，会额外占用内存，如果一个类不会被继承就会浪费额外地内存空间，只有需要作为父类的时候才会设置为虚函数。

### 11. 析构函数的作用
构造函数与析构函数对应，对象的生命周期结束时会自动执行析构函数。

析构函数与类名相同，构造函数与类名相同，析构函数会在函数名前加一个~fun()

析构函数只能有一个，不能够重载，所以父类的析构函数必须写成虚函数，如果用户没有编写析构函数，编译器会合成一个析构函数，默认的析构函数没有操作。

如果自定义的类中有指针，且会动态申请内存，则析构函数需要释放空间，避免内存泄漏

析构函数顺序：派生类本身的析构函数>对象成员析构函数>基类析构函数

### 12. 静态函数与虚函数的区别
静态函数在编译时确定了运行时机
虚函数在运行时动态绑定
虚函数使用了虚函数表机制，调用时会增加一次内存开销

### 13. 重载和覆盖
重载：函数名相同，但是参数列表的个数与类型不同
覆盖：子类重写了父类的虚函数

### 14. static关键字
1. 全局变量：加了static之后全局变量只能在本文件中使用

2. 局部变量：存储在数据段上，而普通的局部变量分配在栈中，当栈被释放会释放掉

3. 类成员：加了static就没有this指针了，必须通过类名访问

### 15. 虚函数和多态
1. 多态分为静态多态与动态多态，大意是同一个函数在不同情况下有不同的实现方式

静态多态是重载，在编译时已经确定，通过参数列表实现多态
动态多态是虚函数实现的，在运行期间动态绑定，父类的指针指向子类的对象时会调用子类重写后的函数。

2. 虚函数：类的存储最开始部分是个虚函数指针，指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段中（txt文件）。

子类继承父类时会继承虚函数表，当重写父类函数时，会将虚函数表地址替换为新的函数地址（新的函数也在代码段中）

使用虚函数可会增加内存开销，降低效率

### 16. strcpy和strlen函数
str是字符串，cpy是拷贝，len是长度
char *strcpy(char *dest, const char *src);
拷贝，遇到'\0'结束，可能会拷贝越界
len返回字符串从开始到'\0'之间的字符串个数

### 17. i++与++i
++i先自增1再返回，i++先返回i再自增1
    ++i
    int&  int::operator++（）{
        *this +=1；
        return *this；}

    i++
    const int  int::operator（int）{
    int oldValue = *this；
    ++（*this）；
    return oldValue；}

从函数的返回值类型看出来不同，实际上i的值已经变了，只是返回的是另一个临时const

### 18.？？写个函数在main之前先运行
__attribute((constructor))void before()
{
    printf("before main\n");
}

### 19. 奇怪的代码
    for(int i = 0; i + 20; i--)
    cout << "hello" << endl;
i+20实际上是判断i+20==0?

### 20. 找不同
 const char * arr = "123"; 
 字符串保存在常量区，不能修改，而指针的内容也不能改变
 char * brr = "123"; 
 字符串保存在常量区，arr的内容可以修改，但是不能通过arr修改“123”的值

 const char crr[] = "123"; 
 123通过编译器优化会放到常量区，不能通过指针操作修改123的值

 char drr[] = "123";
 字符串保存在常量区，但数组复制到栈区，可以通过drr修改字符串的值

### 21. ？？常量
常量在c++定义是个top—level const加上对象类型，常量定义必须初始化

局部对象，常量存放在栈区
全局对象，常量存放在静态（也叫全局）存储区
字面值常量，存放在常量存储区

### 22. 为啥用const修饰成员函数
const表明成员函数调用不会对对象做出更改
当确认成员函数不会对对象做出更改就应当使用const修饰

### 23. C++栈空间的最大值
默认是1M，但是可以调整

### 24. extern"C"
C++调用C的函数需要extern C，是由于C语言没有重载

### 25. 隐式类型转换
低精度的变量给高精度的赋值会有隐式类型转换
单参数的构造函数，传入一个参数时，编译器会自动调用构造函数生成临时对象

### 26. new/delete与malloc/free的区别是什么
new/delete是C++的关键字
malloc/free是C语言的库函数

malloc必须声明申请空间的大小
new在创建类时，会调用类的构造函数与析构函数

### 27. RTTI（运行时类型检查）
C++中有两个操作符dynamic_cast和typeid，
typeid操作符，返回指针和引用所指的实际类型。
dynamic_cast操作符，将基类类型的指针或引用安全地转换为派生类型的指针或引用。

如果存在虚函数，在虚函数表的-1位置存放type_info指针，上面两种操作符会查询type_info的类型信息

### 28. 虚函数表如何实现多态的
每个类有一个虚表，虚表的每个条目是一个虚函数指针对应一个虚函数

子类继承父类的虚表，当子类重写父类的虚函数时，虚函数指针会改写为重写后的函数地址

而子类创建的每个对象头部存放有指向子类虚表的指针

### 29. C语言如何进行函数调用的
函数调用会分配函数栈，在栈内进行函数执行过程
调用函数int fun()之前，先将返回地址int *a压栈，再将当前函数的esp指针压栈

### 30. C语言参数的压栈顺序
从左到右压栈

### 31. C++如何处理返回值
先生成一个临时变量，将变量的引用作为函数的参数传入函数内，最后return时候通过引用修改临时变量

### 32. malloc与new
malloc需要给定申请空间的大小，并且需要类型转换
new是调用构造函数，不用声明大小，类型不用转换

## 第二节 容器与STL
### 33. 容器基础
容器是用来保存其他对象的，一个对象相当于一个物件，容器相当于一个箱子，用来装其他物件的（当然箱子本身也是一个物件）

容器的优势在于可以动态扩展，不像数组是固定大小而定

STL是标准模板库，实际上就是各种容器的集合

通用容器分为三类：
    1. 顺序性容器：vector，deque，list
    2. 关联容器：set，map
    3. 容器适配器：stack，queue，priority_queue

顺序性容器各元素有线性关系，逻辑上是线性表
关联式容器是二叉树结构，可以键值方式保存
容器适配器


### 34. 容器map与set的区别与实现方式
map与set底层都是使用红黑树实现的，几乎所有map与set的操作都是调转红黑树的操作

相同：都是C++的关联容器
不同：
    1. map是键值对应的，关键字其索引作用，值是相关联的数据，set是关键字的简单集合，set每个元素只有一个关键字（set是学号表，map是成绩单） 
    
    2. map的迭代器可以修改value，不能修改key，set的迭代器只能查找不能修改，是const的
    
    3. map支持下标操作，可以用key作为下标，[]是下标运算符，将 []的内容作为key查找，若查找失败就插入一个key为该值，value是默认值的元素进map，尽量少使用下标，能用find就用find


### 35. STL的allocator
作用是封装容器在内存管理上的底层细节

例如new有两个阶段：先调用new配置内存，再构造内存中的内容
delete两个阶段：先调用析构函数，删除对象信息，再释放内存

配置内存有allocate()负责
构造内存由construct()负责

为了提升内存管理效率，减少内存碎片问题，使用两级配置器，分配空间大于128B使用第一级配置器，小于时候使用二级空间配置器
一级空间配置器直接使用malloc，free函数
二级采用内存池技术，通过空闲链表管理内存

### 37. STL中map与set数据存放方式
由于map的元素还是有顺序的，所以使用红黑树
而unordered map底层结构是哈希表

### 38. STL的组成部分
容器
分配器：为容器分配寸触控阿金
迭代器：用来遍历容器中的对象，自己定义遍历的顺序
算法：通过迭代器获取容器中的内容
仿函数：协助算法完成各种操作
配接器：套接适配仿函数

### 39. STL中的map与unordered_map
map的所有元素都是pair<key,value>,所有元素会根据元素的key自动排序，key值不能重复，value可重复

（键值是主键值key，实值是真实数值value）

multimap是多重映射，允许key重复

unordered_map不会根据key排序，底层使用哈希表存储

### 40. vector与list的区别与应用
vector是封装了数组，list是封装了双向链表
vector在堆上分配空间，插入或者删除在最后很快，在中间需要拷贝复制，需要的时间较长，适用于随机访问

list也在堆上分配空间，随机访问性能很差，但是插入很快

vector也不是动态的，为了效率考虑，是一次性分配好内存，当内存不够用时才进行两倍的扩容，只是封装了这一过程，抽象动态分配

### 41. 有了指针为啥还要迭代器
迭代器是提供一种方法顺序访问一个容器中的各个元素
但是一般只用于底层的容器，比如list，vector，stack等容器类

迭代器不是指针，而是类模板，封装了指针的操作符与功能

迭代器返回的是对象引用而非对象的值

迭代器的产生式为了将不同集合类的访问逻辑抽象出来，在不用了解集合内部的情况下实现遍历集合的效果

### 42. STL迭代器如何删除元素的
1. 对于vector，deque而言，使用erase(itertor)后，后边每个元素的迭代器会失效，但是每个元素会向前移动一个位置，erase会返回下一个有效的迭代器

2. 对于map，set而言，使用了erase(itertor)之后，当前的迭代器失效，但是下一个元素的迭代器不影响，只要记录下一个元素的迭代器即可

3. 对于list而言，两种方式都可以使用，常用的是使用erase会返回下一个有效的itertor

### 43. ？？一道题 挺奇怪
n个整数组成的无序数组，要用O(n)的时间找到每个元素后面比他大的第一个数

利用了栈去做的，等会看
```cpp
vector<int> findMax(vector<int>num)
{
    if(num.size()==0)//养成好习惯
        return num;
    vector<int>res(num.size());//new vector
    int i=0;
    stack<int>s;
    while(i<num.size()){
        if(s.empty()||num[s.top()]>=num[i])
            s.push(i++);
        else{
            res[s.top()]=num[i];
            s.pop();
            }
    }
    while(!s.empty())
    {
        res[s.top()]=INT_MAX;
        s.pop();
    }
    for(int i=0; i<res.size(); i++)
        cout<<res[i]<<endl;
    return res;
}

```

### 44. STL里面set和map如何实现的
set（集合）：特点是元素会根据key的大小自动排序，底层使用红黑树实现，红黑树是二叉平衡树，自动排序的效果很好，几乎所有的set操作都是转调红黑树的操作

map（映射）：也是通过红黑树实现的，也是通过key的值自动排序的

### 45. STL里面resize和reserve的区别
resize()是改变当前容器内元素的数量，新增元素或者删除元素
reserve()是改变当前容器的最大容量（capacity），如果reserve(len)的值大于capacity()的值，会重新分配一块能存储len个对象的空间，将之前的对象复制过来，销毁之前的内存

### 46. ？？epoll的原理
调用顺序：
int epoll_create(int size);

int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);

int epoll_wait(int epfd, struct epoll_event *events,int maxevents, int timeout);

首先创建一个epoll对象，然后使用epoll_ctl对这个对象进行操作，把需要监控的描述添加进去，这些描述如将会以epoll_event结构体的形式组成一颗红黑树，接着阻塞在epoll_wait，进入大循环，当某个fd上有事件发生时，内核将会把其对应的结构体放入到一个链表中，返回有事件发生的链表。

### 43. C++类成员的访问权限
访问权限分为三类：
    publiuc：在类的外部通过对象访问
    protected：友元类可以访问
    private：只有类成员函数能够访问，对外不可见

访问权限是为了实现封装

### 44. C++中struct和class的区别
两种都可以定义类，都可以继承
struct的默认继承权限与默认访问权限是public
class的默认继承权限与默认访问权限是private

### 45. C++类的引用数据成员
引用相当于别名，&a，在类中可以定义引用数据成员，但是必须通过成员函数初始化列表初始化

### 46. ？？右值引用与左值引用
右值引用是C++11中引入的新特性 , 它实现了转移语义和精确传递。它的主要目的有两个方面：
1. 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。

2. 能够更简洁明确地定义泛型函数。


左值和右值的概念：

左值：能对表达式取地址、或具名对象/变量。一般指表达式结束后依然存在的持久对象。

右值：不能对表达式取地址，或匿名对象。一般指表达式结束就不再存在的临时对象。


右值引用和左值引用的区别：

1. 左值可以寻址，而右值不可以。

2. 左值可以被赋值，右值不可以被赋值，可以用来给左值赋值。

3. 左值可变,右值不可变（仅对基础类型适用，用户自定义类型右值引用可以通过成员函数改变）。

### 47. C++文件从文本到可执行文件的过程
1. 预处理：对头文件进行替换，对于宏定义进行替换
2. 编译：将预处理后的文件转换为汇编代码文件
3. 汇编：将汇编文件转为机器码，生成可重定位目标文件
4. 链接：将多个目标文件与库链接成为可执行文件

### 48. #include包含的头文件顺序，“”与<>的区别
文件顺序：若在a.h中声明了在b.h中定义的变量，但是a.h没有引用b.h，就应当在a.c中，将b.c放在a.c之前

双引号和尖括号的区别：预处理阶段查找头文件路径不同

双引号不一定只是本地文件，顺序如下：
    当前头文件目录
    编译器指定的头文件路径
    系统变量指定的头文件路径

尖括号的头文件：
    编译器指定的头文件路径
    系统变量指定的头文件路径

## 第七节：内存管理
### 49. malloc的原理说一下
malloc用于动态内存分配
注意的是减少内存碎片，减少系统调用的开销

原理是使用内存池，先申请大块内存作为堆区，将堆区分为多个内存块，块作为内存管理的基本单位，申请内存时从堆区分配一块合适的空闲块

malloc用隐式链表将所有块组成已分配块链表和未分配块链表
用显示链表结构（双向链表）管理所有的空闲块，每个空闲块记录一个连续未分配的地址
（可以使用最坏匹配法，选取最合适的分配）
（同时使用边界标记法，会将内存块进行合并）

malloc在申请内存时候，根据申请内存的大小分为二级分配，当小于128k时，调用brk系统调用在堆区分配，大于128k时，调用系统函数mmap在映射区分配

### 50. C++如何进行内存管理的
虚拟内存分为六部分，分别管理存储不同区段

代码段：存储代码，使用ASCII的形式存储

数据段：存储已经初始化的全局变量与局部变量

bss段：存储未初始化的（或初始化为0）全局、局部变量

堆区：调用malloc/new,delete/free来申请释放的内存

映射区：存储动态链接库，或者mmap函数进行的文件映射

栈：使用栈空间存储函数的参数，返回地址，返回值等等

### 50.5 C++如何进行内存分配的
32bit的CPU有4G的内存空间，则每个进程有独立的4G逻辑地址，
0-3G是用户态空间，3-4G是内核空间

内存空间分为两部分：
1. 静态区域：（一般不会动态改变大小）
    代码段（code segment）
    数据段（data segment）
    bss segment（存放未初始化的局部+全局变量）

2. 动态区域：（大小是动态申请改变的）
    堆：只有当进程调用malloc时才分配个堆（小内存）
    映射区：存储动态链接库，申请大内存
    栈区：存储参数，返回值，返回地址，局部变量等

### 51.什么是内存泄露（memory leak）
内存泄露值得是程序未能释放掉不再使用的内存的情况，有三种泄露方式：
    1. 堆内存泄露：使用malloc却没有delete
    2. 系统资源泄露：程序使用系统分配的资源，比如bitmap，socket等等却没有使用相应的函数释放掉
    3. 未将基类的析构函数定义为虚函数：基类指针指向子类对象时，子类的析构函数没有调用，子类的资源没有释放，资源泄露
### 52. 如何判断内存泄露
内存泄露指的是调用malloc/new申请内存，却没有调用delete/free释放申请的空间
有两种方式：
    1. 使用linux环境下的内存泄露检查工具valgrind
    2. 写代码时可以添加内存申请与释放的统计功能，判断释放与申请的是否一致

### 53. 什么时候会出现段错误
1. 使用野指针（你都不晓得这个指针指向的什么东西），野指针是在释放空间之后没有销毁的指针
2. 试图修改字符串常量的位置

### 54. new和melloc的区别
1. new按照数据类型分配，malloc按指定大小分配
2. new直接返回指定类型的指针，malloc返回void*型，需要类型转化过来
3. new不仅分配内存，而且会调用构造函数，malloc只分配空间，new要用delete，delete还会调用析构函数
4. new是个操作符可以重载，malloc是个库函数不能重载
5. malloc分配的内存不够的时候可以使用realloc扩容

### 55. C++ STL的内存优化
1. 二级配置器(128K分配内存)
    第一级分配大于128的空间（malloc，free）
    第二级分配小于128的空间（new，delete）

2. 二级内存池

    第二级由内存池管理，配置一大块内存，维护对应的16个free-list（大小分别是8,16,24~128）
    
    找到对应大小的freelist分配，用户申请的空间扩展为8的倍数，找到相应大小的子链表
    （如果相应大小的freelist没有了，就向内存池申请，如果内存池也不够用，就使用一级配置行了）

## 第八节 C++11
### 56. C++11的新特性
1. auto关键字：
    编译器能根据初始值自动推导出类型
    （不能用于函数传参和数组类型的推导）

2. nullptr关键字
    可以被转换为任意其他的指针类型

3. 智能指针
    std::shared_ptr,std::weak_ptr等智能指针

4. 初始化列表
    使用初始化列表对类进行初始化

5. 右值引用
    实现移动语义，消除两个对象交互时不必要的对象拷贝

6. atomic原子操作：
    用于多线程资源的互斥操作

7. 新增STL容器：array和tuple

### 56.5 ？？介绍几个新特性 二章八节
1. 可变参数模板
2. 右值引用
3. lambda
### 57. ？？补充C++右值引用
1. 左值和右值
```cpp
    int a=0;
    //a是左值，0是右值
    //区分左值与右值是看能否取地址
    //0是个常数，但a是变量能取地址
```
2. 左值引用&
    左值引用就是给变量起个别名
```cpp
    int a=1;//a是左值，1是右值
    int& refA=a;//refA就是给a起了个别名
    int& b=1;//编译错误，对右值不能使用左值引用
```
3. 右值引用&&
    可以实现移动语义，完美转发，消除不必要的对象拷贝

# 第二章 操作系统
### 1. 说说线程和进程的概念和区别
进程
    1. 是对运行时程序的封装
    2. 是**系统资源**调度分配的基本单位
    3. 用于实现操作系统的并发

线程
    1. 是进程的子任务
    2. 是**CPU调度**分配的基本单位
    3. 用于保证程序的实时性
    4. 是操作系统最小的执行与调度单位
    5. 线程共享地址空间，独享虚拟处理器

区别
    1. 一个进程可以有多个线程
    2. 进程有独立的内存单元，多个线程共享进程内存
    （共享代码段，数据段，堆区，独享栈区）
    3. 进程是资源分配最小，线程是CPU调度最小单位
    4. 进程切换时候开销大（CPU环境），线程开销小（寄存器）
    5. 线程之间可共享数据段通信，进程需要同步互斥
    6. 进程编程调试简单，但 创建销毁开销大，线程反
    7. 进程之间不会相互影响，但挂一个线程会挂进程
    8. 进程适用于多核，多机器，线程适用于多核

进程之间通信方式
1. 管道
    1. 普通管道
        半双工
        可以看做文件，但是不属于文件系统
        只能在父子进程或者兄弟进程之间
    2. 命名管道 
        可在无关进程之间交换数据
        管道与路径名关联，是种特殊的文件形式

2. 系统IPC
    1. 消息队列
        将消息组成链表的形式，放在内核中，一个消息队列有一个队列ID标记

        有权限的进程可以添加新消息，有读写权限的进程可以读取消息

        **特点：**
        消息面向记录，有特定的格式与优先级
        熊爱队列独立于发送与接收进程，进程终止不影响消息队列的内容
        消息队列可以实现随机查询，不一定要先进先出的次序读取

    2. 信号量
        信号量是个计数器，控制对个进程对于共享资源的访问，信号量用于实现进程之间的互斥与同步
        信号量用于实现PV操作

        **特点：**
        信号量只用于进程同步互斥
        对于信号量的操作的原子操作
        对于信号量的PV操作可以加减任意正整数
        支持信号量组
    
    3. 信号
        发送信号通知接收进程某个事件已经发生
    
    4. 共享内存
        共享内存空间，但是需要同步互斥
        信号量+共享内存结合使用
    
3. 套接字SOCKET
    除了两个进程之间的通信，也可以用于不同主机之间两个进程的通信

线程之间的通信方式
1. 临界区：通过多线程串行化访问
2. 互斥量：只有有mutex才能访问
3. 信号量：signal，限制访问资源的线程数目
4. 事件：通过通知操作保持多线程同步

### 2. 虚拟地址空间
虚拟地址空间是为了解决不同进程对物理内存的访问冲突

每个进程虚拟为自己独占当前系统的全部内存，将自己的虚拟内存空间映射存储到物理内存上

实际上，每个进程不是将虚拟内存对应的程序数据和代码拷贝到物理内存，而是建立虚拟内存和磁盘文件的映射

优点：
可以扩大地址空间，可以内存保护，可以公平分配内存
可以通过共享虚拟内存的方式实现进程通信
适合多道程序设计系统使用
只需要在虚拟内存空间分配连续空间，不用实际物理内存的连续空间，可以利用碎片

### 3. 并发和并行
并发：宏观上是两个程序同时运行，微观上是交替运行，不能提高计算机的性能，只能提高效率

并行：严格物理意义上的同时运行，是通过多核CPU实现的

### 4. 缺页中断
缺页中断：请求分页系统中，可以查询页表的状态为确定访问的页面是否在内存中，如果不在，执行中断，将该页调入内存

缺页中断步骤：
保护CPU，分析中断原因
转入相应中断处理程序，恢复CPU现场

中断信号可以在指令执行期间产生，可以产生多次，恢复中断后执行下一条指令

### 5. fork和vfork
1. fork()
fork创建一个新的进程，与调用fork的进程几乎一模一样
fork长江一个新的进程，后使用exec载入二进制映像，替换当前进程的映像

fork要将数据结构复制，复制进程的页表项，将父进程地址空间的内容逐页复制到子进程的地址空间中，而linux做了优化，使用了写时复制的方法

2. vfork()
由于没有使用写时复制，在调用fork或立即执行exec会造成地址空间的浪费，所以引入了vfork

vfork调用产生的结果与fork一样，但会挂起父进程直到子进程终止，这样可以避免地址空间的按页复制，只需要复制内部的内核数据结构，但是子程序不能修改地址空间中的任何内存

3. 改进后的fork使用了写时复制
多个进程共享相同的资源，只用保留指向该资源的指针即可，不用复制占用地址空间

但是当有进程需要改写资源时，才会复制，并且不必复制整个地址空间，只复制要改写的页

由于在fork之后会跟着执行exec，所以复制全部地址空间会浪费时间，但写时复制可以进行优化

### 6. MySQL的端口号是多少，如何修改
通过命令：show global variables like ‘port’
mysql是3306
SQLserver是1433
通过编辑/etc/my.cnf文件增加端口参数，设定端口号

### 7. 有了进程为啥还要有线程
进程在同一时间只能做一件事，进程如果阻塞，整个进程就会挂起

线程切换的开销小，可以提高并发性，线程共用资源，占用的资源少，线程之间通信方便快捷

线程还可以提高CPU的并发性，改善程序结构

### 8. 单核机器写多线程程序，是否加锁
要加锁，在抢占式OS中，为每个线程分配时间片，时间耗尽会被挂起，如果多个线程共享某些数据，不使用线程锁时，修改共享数据会引起冲突

### 9. 线程保存哪些上下文
当前线程ID，线程状态，堆栈，寄存器状态
寄存器：
sp：堆栈指针，指向栈顶地址
pc：程序计数器，存储下一条要执行的指令
eax：累加寄存器，用于加法与乘法

### 10. 游戏服务器应该为每个用户开进程还是线程
开进程，同一个进程内线程会相互影响，一个线程死掉会让进程崩溃

### 11. 说说多进程与多线程不同
1. 进程是资源分配最小单位，线程是CPU调度最小单位
2. 多线程通信简单，占用地址空间少，适用于多核分布式，但是线程之间相互影响，系统可靠性差
3. 多进程有独立的地址空间，可靠性强，但是创建销毁切换的开销大，进程通信复杂，适用于多核多机分布

### 15. 说说线程间的同步方式
1. 信号量
signal是个自然数，只支持PV操作
P操作：信号量大于0就减一，等于0就挂起
V操作：如果有其他线程再等就唤醒，将信号量加1
sem_wait（sem_t *sem）：
sem_post（sem_t *sem）：

2. 互斥量
当进入临界区时，需要互斥加锁，离开时互斥解锁
pthread_mutex_init:初始化互斥锁
pthread_mutex_destroy：销毁互斥锁
pthread_mutex_lock：上锁（原子操作）
pthread_mutex_unlock: 解锁（原子操作）

3. 条件变量
当共享的数据变量到达某个值，唤醒等待这个共享数据的线程
pthread_cond_init:初始化条件变量
pthread_cond_destroy：销毁条件变量
pthread_cond_signal：唤醒一个等待目标条件变量的线程。哪个线程被唤醒取决于调度策略和优先级。
pthread_cond_wait：等待目标条件变量。

4. 事件
通过通知的方式实现多线程同步

### 16. 说说OS的缺页置换算法
访问内存中不存在的页，而内存满了，需要从内存中选出一个页放入对换区，腾出空间替换待访问的页
1. FIFO：先入先出
    （使用队列，无法体现页面冷热）
2. LRU：最近最少使用
    （缓存颠簸，缓存污染）
3. LRU-k：淘汰第k次访问离现在最久的
    解决缓存污染
3. LFU：最不常用
    （需要排序的开销，缓存颠簸）

### 17. 多进程和多线程的使用场景
多线程优势是线程间切换代价小，适用于IO密集型，适用于单机多核分布式

多进程适用于CPU密集型，或者多机分布式场景

### 18. 死锁产生的条件，如何解决死锁
互斥，请求保持，不可剥夺，环路等待

解决就是破坏其中一个条件
资源一次性分配，可剥夺资源，资源有序分配

### 19. 结构体对齐，字节对齐
有两个原因：
    1. 平台：不是所有硬件平台都能访问任意地址上的任意数据，某些硬件只能在某些地址处去特定类型的数据
    2. 性能：数据结构在边界上对齐，可以减少访存的次数，未对齐访问两次，对齐了只访问一次

结构体对齐的规则：
    #pragma pack(n)，n=1,2,4,8,16，n是对齐系数
    1. 数据成员对齐
        第一个放在offset=0处，和面的数据还曾元按照n与吱声长度中较小的进行
    2. 结构整体对齐
        按照n与最大数据成员长度中较小的那个进行

    对齐就是偏移量必须是选出来的数的整数倍

### 20. 讲述一下互斥锁的机制，互斥锁与读写锁的区别
1. 互斥锁：mutex 任何时候只能有一个进程访问临界区
2. 读写锁：rwlock 可以有多个读进程，只能有一个写进程（读者写者问题）

Linux有4种锁机制
1. 互斥锁:mutex
2. 读写锁:rwlock
3. 自旋锁:spinlock 不会进入睡眠，而是自旋等待，节省休眠唤醒的时间
4. RCU：read-copy-update 读取数据，生成副本，修改副本，更新数据，这种不需要锁竞争

### 21. 进程与线程的区别
稳定性：线程容易相互影响
切换开销：线程小
创建销毁开销：线程小
通信开销：线程通信方便，开销小

### 22. 进程状态转换
创建->就绪  ->  执行->终止
       -> 阻塞  ->

当多个进程竞争内存资源时，多IO的进程获取内存会降低CPU效率，其他进程都在等着，所以需要腾出内存空间
    1. 交换技术：将不用的进程换到外存
    2. 虚拟存储技术：将每个进程只装入一部分程序

挂起：被交换技术换到外存的进程
阻塞：在内存，但是在等某种资源
就绪：在内存，只等CPU就行了

### 23. A* a = new A; a->i = 10 内存发生了什么
1. A* a : 创建一个指针，并在栈区开辟空间
2. new A: new会在堆区申请A大小的空间
3. a=new A:将堆区地址填入栈中
4. a->i=10：先找到指针的地址，再找i的偏移地址，将该内存地址内存为10

栈区为临时变量分配空间，堆区用于动态分配内存

### 24. 有一个类，里面有static，virtual，在内存是如何存储的
1. static
    static成员变量
        静态成员变量，所有类的实例都共享同一个静态成员变量，所以在全局数据区分配内存
    static成员函数
        static不和实例联系，所以没有this指针，只能访问静态数据，只能调用静态函数
        在代码区分配内存

2. 多态
    动态多条通过虚函数实现的，在运行时确定
    动态多态=虚函数+基类指针指向子类对象
    基类指针会查找该对象的虚函数表，用表中的函数指针调用，每个对象都共用子类的虚函数表

3. virtual修饰符
![pic](/pic/intern/1.png)
虚函数，虚函数表的存储方式
这张图很清楚，有时候概念说不清楚，自己就通过画图理解，ipad是个好工具，起码画图理解很方便

### 25. 软链接与硬链接的区别
硬链接：文件内维护一个count，表指向该文件的指针数
软链接：文件本身不知道有多少指向它，只有创建者通过指针，访问者通过路径名访问，访问效率低，访存次数多

### 26. 大端小端如何判断
大端是低字节存储在高地址
小端存储是低字节存储在低地址

### 27. 静态变量什么时候初始化
静态变量存储在数据段与bss段
C语言在代码执行之前初始化
C++是在对象首次用到时构造

### 28. 用户态和内核态的区别
最大的区别是特权级不同，内核态有较高特权级
运行在用户态的程序不能访问内核数据结构和程序
用户态通过系统调用，中断和异常转换为内核态

### 29. 如何设计server才能够接收多个客户端的请求
多线程，线程池，IO复用

### 30. 如何唤醒被阻塞的线程
阻塞时给缺少的资源

### 31. windows的消息机制
用户有操作的时候，系统将操作转化为消息，每个打开的进程系统都给他维护了一个消息队列，程序循环从消息队列中取出消息，完成对应的操作

### 32. 内存溢出
当申请内存时，没有足够的内存供申请者使用
原因：
1. 内存中的数据量庞大，从数据库中取出的数据过多
2. 集合类中对对象使用完后没有析构
3. 启动参数内存值设定过小

### 33. ？？常用线程模型
第三章第二节末尾
1. future模型
2. fork&join模型
3. actor模型
4. 生产消费者模型
5. master-worker模型

### 34. ？协程是什么
协程也叫微线程，可以中断交错执行，一个线程内有多个协程
特点有两个：
    1. 有很高执行效率
    2. 不需要多线程的锁机制

### 35. 系统调用
系统调用是内核服务接口，用户在用户态没有权限调用内核实现的功能，通过系统调用转为内核态，由内核执行
例如文件的open，write，fork，vfork

### 36. ？？写一个fork调用实例
fork可以创建一个和当前进程映像一样的进程
常见的用法是fork一个新进程，使用exec载入二进制映像，替换当前进程映像

### 37. 用户态到内核态的转化原理
三种方式转化到内核态
1. 系统调用：用户通过系统调用转换
2. 异常：CPU与内存内发生的错误，比如缺页异常
3. 中断：外部IO的中断信号

切换的过程：
1. 从当前进程描述符中提取内核栈信息
2. 通过内核栈保存环境
3. 通过中断向量执行中断处理程序，转到内核态执行

### 38. 源码到可执行文件的过程
1. 预编译：处理宏定义，替换头文件
2. 编译：将高级语言编译成汇编代码
3. 汇编：将汇编代码翻译成二进制机器码
4. 链接：将多个目标文件链接形成exe文件

### 39. 微内核与宏内核
微内核只在内核中实现基本的功能，比如进程管理，内存管理，速度快，稳定性好，但是效率低

宏内核也叫大内核，还将驱动，文件系统，网络协议等也集成在内核中，Linux就是大内核，效率高但是稳定性差

### 40. 僵尸进程与孤儿进程
子进程是父进程创建的，子进程无法创建孙进程
父进程无法知道子进程何时结束

子进程退出时，内核释放文件，内存资源，但是仍旧保留了信息：进程号，运行状态，退出信息
这些信息要父进程通过wait取时才会释放

僵尸进程是子进程退出，父进程还未使用wait获取信息
孤儿进程是父进程退出，子进程会被1号进程收养

大量存在僵尸进程会占用进程号，就没有新的进程可以创建了

两种解决僵尸进程的方式：
1. 子进程退出时发送信号
2. fork两次，子进程会变成孤儿进程，通过init进程处理 

### 41. GDB调试与条件断点
GDB就是通过断点暂时终止程序的执行，可以随时查看变量与内存的状态

可以通过语句设置条件断点，即满足语句条件就触发中断

### 42. 5种IO模型
1. 阻塞IO：调用某个函数，一直等该函数返回才继续
2. 非阻塞IO：每隔一段时间检测一次IO是否就绪
3. 信号驱动IO：IO就绪后会发送信号，接收到信号响应IO操作
4. IO复用：使用select/epoll实现，同时阻塞多个IO
5. 异步IO：可以等内核将数据拷贝到缓冲区后再通知应用程序

### 43. 为什么操作系统要分内核与用户态
为了安全性，用户态管理内存出错误可能导致系统崩溃，通过内核执行操作，对外提供API，可以避免用户对系统的影响

### 44. 说说操作系统的中断
中断的目的是为了暂停当前程序的执行，转去执行另一个程序，当执行完后回来接着执行

分为三种：IO等造成的外部中断，内部错误（越界溢出缺页），在程序中使用系统调用

处理过程两步：中断响应，中断处理

### 44. ？？如何实现线程池
### 45. ？？linux内核中的timer定时器机制


# 第三章 计算机网络
### 1. TCP如何保证可靠性
1. 序列号，ACK，超时重传
通过序列号，ACK，超时重传实现
超时重传时间一般是2*RTT+偏差值

2. 窗口与快重传
通过窗口控制实现同时发送多个数据段
窗口的大小是无需等待确认就能继续发送数据的最大值
接收窗口发现某个数据段丢失后，会快速发送3个ACK，叫做快重传

### 2. TCP的流量控制
发送方与接收方之间通信，限制发送速率
三种窗口：
    1. 接收窗口：接收方根据缓存大小动态调节
    2. 拥塞窗口：根据网络拥塞程度调节
    3. 发送窗口=min{接收窗口，拥塞窗口}

### 2. TCP的拥塞控制
由网络拥塞程度决定的，限制发送速率
有两种技术实现：
1. 慢开始与拥塞避免
    慢开始：拥塞窗口初始为1，指数式增长
    拥塞避免：当到达慢开始门限，线性增长
    （当出现拥塞时，慢开始门限=拥塞窗口/2，拥塞窗口变成1）

2. 快重传与快恢复
    快重传：使用三个ACK告知出现拥塞
    快恢复：拥塞窗口减半，直接线性增长

### 2. TCP的三次握手与四次挥手
1. 三次握手


2. 四次挥手


### 3. HTTP与HTTPS的区别
HTTP使用明文传输数据，HTTPS要对数据进行加密传输
使用加密安全度更高，但是需要运算，消耗CPU资源
HTTP在三次握手后还要SSL握手，时延大

### 4. IP地址与MAC地址的作用
MAC地址是设备地址，由链路层负责
IP地址是逻辑地址，由网络层负责

MAC地址用于定义设备的地址
IP地址用于提供逻辑上的地址，屏蔽物理地址差异

### 5. OSI的七层与TCP/IP的四层（说协议）
物理层：面向比特，传输二进制数据流
链路层：成帧，点到点传输（PPP）
网络层：数据包点到点的传输（IP，ARP，ICMP）
传输层：端到端，提供可靠传输（TCP，UDP）
应用层：翻译加密等（DNS，HTTP，FTP）
### 6. 搜索百度的过程，每层干啥
先输入URL，通过DNS解析为IP地址
通过IP地址与服务器建立HTTP连接
### 7. TCP的拥塞控制
### 8. TCP/IP链路层的交互过程


# 第四章 数据库
### 1. 数据库索引
索引对数据库汇总一列值进行排序，能快速访问该列信息
相比于在表中搜索所有行能更快地获取信息
目的是加快检索数据表中数据
### 2. 数据库事务
指的是为单个逻辑工作单元执行的一系列操作，只能完全执行或完全不执行

事务有四种属性：
    原子性：要么全部执行，要不都不执行
    一致性：数据库数据满足完整性约束
    隔离性：多个事务执行时，一个事务不影响其他事务
    持久性：已经提交的事务对数据库修改永久保存

隔离性：同一时间内只有个一个事务访问同一数据
一致性：事务执行之前与之后数据库都处于一致性状态
（一致性状态：语义上有意义且正确的状态）
持久性：一个事务一旦被提交，对数据库数据的改变时永久性的，即使数据库有故障也要将事务执行完毕

### 3. 左值连接与等值连接
left join：保留左表中的所有记录
inner join：只返回连接字段相等的行

### 4. 索引是什么，多加了有啥坏处
索引对表字段附加一个标识，对数据库表中一列或者多列的值进行排序，能快速找到匹配的记录行数

缺点：创建与维护索引要耗费时间，索引要占物理空间对表中数据增删改时也要动态维护索引

使用索引的原则：
1. 很少使用的**列**不应该加索引
2. 只有很少数据值的列也不该加索引
3. 当修改性能大于检索性能时不该加


### 5. 数据库三大范式
第一范式：数据库表每一列都是不可分割的原子数据项
第二范式：数据库表中每一列都与主键相关，而不能与主键某一部分相关（针对联合主键）
第三范式：数据表中每一列数据都与主键直接相关，不能间接相关（最好用实例解释理解）

### 6. 数据库四种隔离级别（递增）
未提交读：事务可以读未提交数据（脏读）
提交读：事务在提交之前对其他事务不可见
可重复读：同一事务中多次读取的数据是一致的
可串行化：强制事务串行化执行

用来解决三种问题的：
1. 脏读：a正在访问并且修改，还没有提交的时候b读到了这个数据，a回滚的话，b的数据不变，就是脏读

2. 不可重复读：事务a会重复读取同一数据，但是b在期间修改了数据，a中都是读取，但是两次读取的内容不同
3. 幻读：a事务对表中全部数据行进行修改，但是b插入一行数据，a在结束后发现还有一行没改，像幻觉一样

### 7. 锁与粒度
1. 共享锁（读锁）：互不阻塞
2. 排他锁（写锁）：阻塞其他读写锁
3. 锁粒度：锁定的粒度越小，并发度越高，但是加锁，检测，释放的系统开销随之增大
4. 锁策略：保证开销与安全性的平衡
    1. 表锁：锁住整张表，开销最小
    2. 行级锁：对每一行数据加锁，开销大，高并发

### 8. 数据库引擎对死锁的处理
死锁与OS死锁类似，多个事务相互持有对方要申请资源的锁不释放，造成环路死锁
当数据库检测到死锁循环依赖后，回滚持有最少行级锁的事务（回滚一个锁破开循环）

### 9. 索引的实现方式
有两种索引：B+树索引和哈希索引
1. B+树索引：非叶节点是key值，叶子节点时key-value键值对，叶子结点前后相连且有序
2. 哈希索引：将数据存在不同的bucket中，可以用常数时间查找，注意哈希冲突避免方法

为啥要有两种索引？
1. B+树默认有序，hash默认无序，哈希无法用于排序
2. 哈希O(1)快与B+的O(lgn)
3. 哈希只能进行等值查询，B+可以等值可以范围，可以部分前缀
4. B+树是非线性结构，hash桶是线性结构

### 10. MySQL存储引擎
1. InnoDB：最通用的引擎，支持事务，行级锁，占用系统资源多，并发性占优势
2. MyLSAM：默认的引擎，不支持事务和行级锁，只支持表锁，占用资源少，查询速度快

(大部分情况下，使用MySQL更好)

### 11. SQL优化
1. 在经常性的检索列上建立索引
2. 多次查询同样的数据，可以缓存该组数据
3. 少用select * from tables;
4. 切分查询：大查询切分为多次小查询，避免一次性锁住大量数据
5. 分解关联查询：将关联查询分解成多个单表查询，将结果进行关联，可以减少处理过程的锁争用

### 12. profile的用法
用于保存SQL语句的执行状态
显示语句的执行情况，需要手动开启

### 13. MySQL查询的步骤
1. 客户端发送询问到服务器
2. 服务器检查缓存query，命中则返回结果
3. 解析语句，生成执行计划
4. 根据执行计划，调用API执行查询
5. 结果返回客户端

### 14. MVCC机制
MVCC是用于实现多版本并发控制机制
通过保存数据在时间点的快照实现，将快照存储在undo日志中，日志通过回滚指针将该数据行的所有快照连接起来

### 15. MySQL引擎
MySQL的数据使用不同技术存储在文件中

每种技术都使用不同的存储机制，索引技巧，提供不同的功能和能力

选择不同的技术可以获得额外的速度或者功能

数据库引擎提供存储，处理，保护数据的核心服务

最常用的是InnoDB和Mylsam

### 16. redis
redis是大并发，高性能的数据库，支持多种数据结构，包括hash，set，list

### 17. MongoDB和redis
redis支持的数据类型丰富，包括hash，set，list
MongoDB数据结构单一，但支持丰富的数据表达

redis数据全部存在内存，定期写入磁盘
MongoDB将热点数据存在内存，其他数据存在磁盘

### 18. ？redis的定时机制如何实现
redis是事件驱动程序，处理两类事件：
文件事件
时间事件

时间事件有三个属性：
1. id：时间事件标识号；
2. when：记录时间事件的到达时间；
3. timeProc：时间事件处理器

### 19. redis是单线程的，为什么如此高效
redis的文件处理事件是单线程方式运行的
但是IO多路复用监听多个套接字

即在内部文件处理是单线程的，但是外部实现了高性能的网络通信模型可以与内部单线程模块完成对接

### 20. redis的数据类型与底层实现
1. 字符串：通过整数值 或者 动态字符串实现
2. 列表：通过压缩列表 与 双端链表
3. 哈希：压缩列表 与 字典
4. 集合：整数集合 与 字典
5. 有序集合：压缩列表 跳跃表 字典

### 21. redis的rehash与渐进rehash
redis是单线程的，如果将将键值对全部rehash，计算量太大会影响服务器性能
所以应当分多次，渐进式的rehash
有两种渐进rehash：
1. 当读，插入，删除时候将键值对移到新hash链表中
2. 后台定时任务调用rehash，可以控制调用的频率

### 22. redis与memcached的区别
记不住啊，等问到了再说吧


# 第五章 数据结构
1. 快速排序写一下 啥时候最慢 时间复杂度问题
```cpp
void quicksort(int a[],int low,int high){
    if(low<high){
        int tmp=get_index(a,low,high);
        quicksort(low,tmp-1);
        quicksort(tmp+1,high);
    }
}
int get_index(int *a,int low,int high){
    int tmp=a[low];
    while(low<high){
        while(low<high&&a[high]>tmp)
            high--;
        a[high]=a[low];
        while(low<high&&a[low]<tmp)
            low++;
        a[low]=a[high];
    }
    a[low]=tmp;
    retrun low;
}
```
# 第六章 项目相关
# 第七章 设计模式

------------------------------------

# 第八章 问题池
### 42. ？？？内存与物理内存如何对应的
第三章第一节
### 42. ？？？操作系统中的页表寻址
nmd四级页表寻址？
### 42. ？？？如何修改文件最大句柄数
第三章第一节
### 42. ？？？reactor模型的组成
第二章第七节
### 42. ？？？如何用单线程处理高并发
在单线程模型中，可以采用I/O复用来提高单线程处理多个请求的能力，然后再采用事件驱动模型，基于异步回调来处理事件来
### 41. ？？？ select，epoll的区别原理
第二章第七节 
### 41. ？？？ fork,wait,exec函数
父进程产生子进程使用fork拷贝出来一个父进程的副本，此时只拷贝了父进程的页表，两个进程都读同一块内存，当有进程写的时候使用写实拷贝机制分配内存，exec函数可以加载一个elf文件去替换父进程，从此父进程和子进程就可以运行不同的程序了。fork从父进程返回子进程的pid，从子进程返回0.调用了wait的父进程将会发生阻塞，直到有子进程状态改变,执行成功返回0，错误返回-1。exec执行成功则子进程从新的程序开始运行，无返回值，执行失败返回-1

### 42. ？？？ select函数
select在使用前，先将需要监控的描述符对应的bit位置1，然后将其传给select,当有任何一个事件发生时，select将会返回所有的描述符，需要在应用程序自己遍历去检查哪个描述符上有事件发生，效率很低，并且其不断在内核态和用户态进行描述符的拷贝，开销很大

### 34. ？？？ C++中拷贝赋值函数的形参能否进行值传递？
不能。如果是这种情况下，调用拷贝构造函数的时候，首先要将实参传递给形参，这个传递的时候又要调用拷贝构造函数。。如此循环，无法完成拷贝，栈也会满。

### 27. ？？？ 类型转换
reinterpret_cast：可以用于任意类型的指针之间的转换，对转换的结果不做任何保证
dynamic_cast：这种其实也是不被推荐使用的，更多使用static_cast，dynamic本身只能用于存在虚函数的父子关系的强制类型转换，对于指针，转换失败则返回nullptr，对于引用，转换失败会抛出异常
const_cast：对于未定义const版本的成员函数，我们通常需要使用const_cast来去除const引用对象的const，完成函数调用。另外一种使用方式，结合static_cast，可以在非const版本的成员函数内添加const，调用完const版本的成员函数后，再使用const_cast去除const限定。
static_cast：完成基础数据类型；同一个继承体系中类型的转换；任意类型与空指针类型void* 之间的转换。

### 13. ？？？ fork函数
多进程编程
Fork：创建一个和当前进程映像一样的进程可以通过fork( )系统调用：
#include <sys/types.h>

#include <unistd.h>

pid_t fork(void);

成功调用fork( )会创建一个新的进程，它几乎与调用fork( )的进程一模一样，这两个进程都会继续运行。在子进程中，成功的fork( )调用会返回0。在父进程中fork( )返回子进程的pid。如果出现错误，fork( )返回一个负值。

最常见的fork( )用法是创建一个新的进程，然后使用exec( )载入二进制映像，替换当前进程的映像。这种情况下，派生（fork）了新的进程，而这个子进程会执行一个新的二进制可执行文件的映像。这种“派生加执行”的方式是很常见的。

在早期的Unix系统中，创建进程比较原始。当调用fork时，内核会把所有的内部数据结构复制一份，复制进程的页表项，然后把父进程的地址空间中的内容逐页的复制到子进程的地址空间中。但从内核角度来说，逐页的复制方式是十分耗时的。现代的Unix系统采取了更多的优化，例如Linux，采用了写时复制的方法，而不是对父进程空间进程整体复制。

### 25. ？？？ 智能指针shared_ptr如何实现的

# 汇总
数据结构和算法：二叉树、BST、链表、栈、红黑树、散列表、AVL树、字典树、动态规划、二分查找、递归、各种排序（堆排、快排、归并排、希尔排、桶排）及复杂度稳定性

计网：tcp/ip（握手挥手，各个信号的意义，超时重传，滑动窗口，拥塞控制，流量控制），http/https（长连接短连接，头压缩，服务端推送），tcp/udp，七层模型、四层模型、五层模型

数据库：ACID，隔离级别，常用语句，锁，B树B+树，磁盘操作，存储引擎，主从复制，读写分离，关系型/非关系型，事务/非事务，组合索引，二级索引，范式

操作系统：进程线程协程，进程通信，并发并行，虚拟内存，进程调度，锁，linux，IO复用，链接库，程序运行过程

























































































