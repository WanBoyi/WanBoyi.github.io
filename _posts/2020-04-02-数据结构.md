---
layout:     post   				    # 使用的布局（不需要改）
title:      数据结构考研复习笔记				# 标题 
subtitle:   这是我考研复习时数据结构的记录笔记 #副标题
date:       2020-04-02 				# 时间
author:     WBY 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 计算机基础
---
# WBY的数据结构（精简版）
# 第一章 绪论
### 1.1 基本概念
区分清楚逻辑结构与物理结构
线性表是逻辑结构：分为顺序表（数组）与链表
循环队列一般使用顺序表表示
数据结构三要素：逻辑结构，物理结构，运算
数据逻辑结构与物理结构相互独立的
存储数据时：存储数据元素的数值与数据元素的关系
### 1.2 算法与评价
算法是抽象的概念，而不是具体的程序
算法是对于问题求解步骤的描述
算法的时间复杂度o(n^2)是说明算法执行时间与n^2成正比

**有题型是给出一段代码，让计算具体的时间复杂度**
按照7页的自己总结的算法计算，看随着循环线性增加，逼近循环条件的速度的变化情况
### 1.3 总结
主要内容就是 
1. 逻辑结构与物理结构的区分
2. 时间复杂度的计算
补充一个：递归程序使用递推公式计算时间复杂度



# 第二章 线性表（逻辑结构）
### 2.1 线性表定义与基本操作
说明线性表是逻辑结构
有两种物理实现方式：顺序表与链表
### 2.2 线性表顺序表示（数组）
顺序表示是用数组表示，有三种操作：插入，删除，查找
思路都是先找到位置
插入是其后所有元素后移
删除是其后所有元素前移

数组是随机存取的存储结构
会问：针对不同存取情况，应使用（数组，链表，双链表）
不同的物理结构针对同一操作的复杂度不同，随机应变
### 2.3 线性表的链式表示
注意一点：这个章节中所有链表头结点都带头结点，即一个不含有数据元素的节点，要注意题目中的相关表述
（有的含有一个元素，该元素是链表中节点的个数）

链表的基本操作
1. 建立链表有两种方式：按顺序12345插入建表
头插法建表：每个新元素插入在头结点后第一个（54321）
尾插法建表：建一个临时指针，让其始终指向最后一个元素
（12345）
2. 链表的查找（按内容，按序号）都是线性顺序查找的
3. 链表的插入与删除：
都要找到插入位置的前一个节点操作，找对了指针的关系就可以了
4. 求链表表长遍历一遍就ok了

双链表
定义上就是多一个后继指针
在插入与删除操作时候，可以画个图，标示出指针之间的指向关系与修改顺序即可

循环链表
尾节点next指针指向头结点（第一个带数据的节点）
在判断是否到末尾：节点的next==头结点？
其余操作都相似

循环双链表
尾节点的next指向头结点，头结点的pior指向尾节点
**一定像书上一样，会画出图的结构，更清晰，便于理解**

静态链表
脱裤子放屁，多此一举

1. 在链表中增加一个头结点是为了便于运算的实现
2. 一种题型是给链表删除或插入节点，让选择正确的顺序，方法就是画图表示，选正确顺序
3. 一种题型是告诉你一种操作，让选择最便于实现该操作的链表或顺序表结构（使用排除法，选出答案后验证一下）
### 2.4 总结
本章节是算法设计（大题）的重点考察章节
一般三段式出题
写出正确的数据结构类型定义，正确的算法设计思路，就有一般分数了，不一定要追求最佳解法，这里多看几遍就熟一点



# 第三章 栈和队列
### 3.1 栈
使用的数组的数据结构实现了栈
栈的基本操作是入栈出栈，栈顶-1时为空，0时有一个元素
（也可以用链表的头插法实现栈及其操作）
**选择题就是出栈入栈的题目，注意正难则反，不要思路太死，灵活一点，划清楚过程**
### 3.2 队列
数据从队列尾巴进来，从队列头部出去，记住队列会后移
**最重要的看题目头指针指向队头元素还是队头元素下一个，题目中必定会给出**
**不管哪一种，空的条件一般都是rear=head，看题目**
顺序队列空：S.front==S.rear
顺序队列enqueue：Q.rear!=MaxSize
顺序队列dequeue：Q.head<Q.rear

循环队列只是改变了判断队列满的条件
(更简单了，空与满两种状态)
顺序队列空：Q.front==Q.rear
顺序队列enqueue：(Q.rear+1)%MaxSize!=Q.front
（此时满了）
顺序队列dequeue：Q.rear!=Q.front
（此时为空）

链式队列
数据用链表存储，额外加两个指针，一个指向head，一个指向tail
链式队列enqueue时候：尾部插入
链式队列dequeue时候：头部插入
**题目问头尾时，自己模拟一下出入过程，看能否实现，比如16题**
### 3.3 队列的应用
要知道层次遍历的过程，过完本层后过下一层
广度优先搜索就是层次遍历，需要队列辅助实现
**消除递归不一定使用栈，单向递归与尾递归可使用迭代**
栈只能在一端操作，队列可在两端操作
### 3.4 特殊矩阵可压缩存储
1. 对称矩阵按下三角的顺序从上向下存储
2. 三角矩阵从下向上存储
上三角：1+2+3+···+(i-1)+(j-1)
下三角：n+(n-1)+(n-2)+···+(n-i+2)+(j-i+1)+1
3. 三对角矩阵逐行存储
4. 稀疏矩阵按照三元组存储，或者按十字链表存储
**计算时注意下标，找规律递推就好了，胆大心细**



# 第四章 树和二叉树
### 4.1 树的基本概念
树的深度和高度不一样，叶节点高度最低，深度最大 
树中所有节点的总数=分枝数+1=所有节点总度数+1
**叶子结点是终端节点，非叶子节点是分支节点**
完全二叉树只有最后一层不满
自己画，找结构，想反例
### 4.3 二叉树的遍历和线索二叉树
二叉树前中后三种通过递归实现
可以借助栈不使用递归实现这三种算法
层次遍历使用队列实现，逐层向下走的
访问这一层，就将下一层的节点全部送入队列，按顺序访问

三种顺序构造二叉树：（中序与其他三种的组合）
//使用先序和中序构造二叉树
//使用中序和后序构造二叉树
//使用层次序和中序构造二叉树

方法：每次找出一个根节点，利用中序将其分为左右子树，如此递归下去
**难点考察就在于前中后三种遍历方式**

线索二叉树比较简单，对其中序遍历就知道线索的指向了
### 4.4 树，森林
有三种存储方式，两种依赖于数组，方法简陋
常用的是第三种方法

1. 树与二叉树转换，森林与二叉树的转换
**这里是重点与考点，但是不难**
2. 树两种遍历（先根后根），森林两种（先序，中序）
**这个记住和树的先序中序对应的就行，不会大考**

**树与森林是用的二叉链表在内存中存储的，搞清楚这个物理结构与逻辑结构不同**
**搞清楚问的结论在哪里成立！是在树中还是在森林还是在二叉树中**

### 4.5 树和二叉树的应用 
1. 二叉排序树：左节点<根节点<右节点
二叉排序树查找是递归向下查找的
二叉排序树插入是先查找位置，再插入叶节点
二叉排序树构造是利用插入函数一个一个插入构造的
删除分三种：看书上图就可以

2. 二叉平衡树：左右子树高度差不超过1
**平衡二叉树也是排序二叉树**
二叉平衡树考点在于四种插入（实际上是插入到叶节点然后通过旋转调整）

3. 哈夫曼树，哈夫曼编码
带权路径长度=叶节点权值*根节点到叶节点的路径长度
（累加）
哈夫曼树是带权路径长度最小的树，最重要的是构造哈夫曼树（构造也较为简单，两个节点合成一个节点的值，每次选两个最小的作为左右）
哈夫曼编码只是哈夫曼树的应用（1就延长，0就终点）
**前缀码的定义：没有一个编码是另一个编码的前缀**
**哈夫曼树只有出度为0和2的节点，没有出度为1的节点**



# 第五章 图
### 5.1 图的基本概念
下面几个概念十分重要：

简单图：没有重复边，没有指向自身的边
完全图：任意两个顶点之间都有边
（有向图的完全图是任两个顶点之间有两条边）

极大联通子图：保留边，是无向图的联通分量
极小联通子图：保持连通性，去掉不必要的边

联通分量：非联通的图有多个联通分量，连通图只有一个
（联通分量是极大联通子图，是不动边的）
强连通分量：有向图双向强联通

生成树：连通图的极小连通子图
（图有生成树说明该图是连通图，否则只有生成森林）

路径：由顶点和顶点边的序偶形成的序列
（与弧做区分，弧是直接由a到b顶点）

路径长度是路径上边的数目

图中两点的距离是最短路径的长度
**无向图的重要结论：顶点a乘a的度的累加=2倍的边数**
**有向图的重要结论：所有顶点的出度之和=所有顶点的入度之和（零和博弈）**
### 5.2 图的存储与基本操作
图有四种存储方式，按照不同的特点适用于不同的情况
1. 邻接矩阵（适用于密集图）（有向无向皆可）
最简单的，无向图的邻接矩阵必定是对称的

2. 邻接表（适用于稀疏图）（有向无向皆可）
有个顶点数组，顶点的first指向边表节点
每个边表节点表示顶点节点指向的节点在数组中的位置
（如果存储无向图，同一条边会存两遍，即同一种方式既可以是有向的，也可以是无向的）

3. 邻接多重表（适用于无向图）
每个节点一个指针指向第一个依附于该节点的边
每条边包括两个节点，以及（两条）下一条指向该节点的边

4. 十字链表（用于有向图）
顶点节点指向该顶点的第一条入弧和出弧
边表节点有边的头尾节点和头尾相同的下一节点

存储结构务必要清楚！！

邻接表：顶点节点指向第一条边节点，每条边节点指向下一条边节点（节点内是边的另外一个顶点）

邻接多重表：顶点指向第一条边节点，边表节点指向两个顶点与两个顶点的下一条边

十字链表：顶点指向该顶点的第一条入弧和出弧，每条边节点指向头相同的下一条边节点和尾相同的下一条边节点

**虽然有这几种在一块，但考的时候一般只考察邻接表和邻接矩阵，可以减少记忆负担，只记忆多重表与十字链表分别用于无向与有向即可**
使用邻接表和邻接矩阵有各自的适用情况，没有绝对的方便与不方便

### 5.3 图的遍历
两种算法DFS和BFS，用不同数据结构处理复杂度不同
**不论是DFS，BFS，使用邻接表都是O(n+e),空间复杂度是O(n),使用邻接矩阵都是O(n^2)**
深度优先使用递归，广度优先借助队列
（在这里又体会到栈和队列的重要性）

利用广度优先可以计算从当前顶点出发到各个顶点的单源最短路径（由于广度优先的特点，必然是最短路径，深度优先算法不一定）

拓扑排序是针对一个有向无环图，先访问的必定在后访问的序列之前
**深度优先可以判断是否存在回路**

### 5.4 图的应用
1. 最小生成树
prim：每次找一个点加到树上（只有一棵树）
kruskal：每次找一条边连接（可能同时有多棵树）

2. 最短路径 （**最短路径一定是简单路径**）
单源最短Dijkstra：一轮一轮更新最小值（广度优先遍历）
**O(v^2),并且当边权值为负时不适用**

各顶点之间Floyd：遍历矩阵，代码简单，思路简单
**复杂度O(v^3),允许边权值为负，不允许包含负权值的回路**

3. 拓扑排序：
AOV网：顶点是活动
每次删除一个入度为0的节点，同时删除它的边，一层一层剥除

4. 关键路径：
AOE网：边是活动，顶点是事件
先求事件（节点）的最早最晚时间
再求活动（边）的最早最晚时间
（事件最早时间是正着算，最晚时间反着算）
活动时间根据事件时间算出来，早对早，晚对晚
活动的早晚时间相减，差值为0的活动是关键活动
由关键活动可以组成关键路径

**DAG图是有向无环图，用于表示工程问题**



# 第六章 查找
### 6.1 顺序 折半 分块查找
分块查找平均查找长度=索引平均查找长度+块内平均查找长度=（b+1）/2+(s+1)/2 （+1这个很重要，不要漏了）
二分查找是在一个二叉树上找的，树上每个节点都是一个元素
二分查找只能以顺序表形式，不能以链表形式
顺序查找不一定就比二分查找慢，两者速度无法比较（对于查找元素是分情况的）
二分查找的树是一颗平衡二叉树
分块查找，块内不一定就要有序，无序使用顺序块内查找
分块数目=数据总数开方

二分查找树是上下取整的问题
### 6.2 B树和B+树
阶指的是子树的最大个数

B树叶节点不带信息，且都在同一个层次上（找到叶节点说明查找失败）
B树也是有序查找树
B树高度不包括叶节点那一层
B树插入在最底层非叶节点那一层
插入时超过了阶数，需要分裂节点
B树删除需要对相应节点进行适当调整
[计算阶的时候，将叶节点的最大数目也要算在内]
[选择题中，根节点与其他分支节点不同，根节点至少2个]

B+树
B，B+根节点至少两颗子树，每个节点至少m/2(上取整)子树
B+是子树数量等于节点元素数目
B+树是信息在叶节点中
B+树非叶节点只含有子树最大关键字与指向子树的指针

B+树既可以从最小关键字开始顺序查找，也可以从根节点开始多路查找（每次查找都是从根节点到叶节点的一条路径）

B+树用于建立关系数据库中的索引
### 6.4 散列表
**大致记住每一个方法是如何处理的**
**平均查找长度直接受堆积现象影响**

平均查找长度=（概率*该元素查找长度）累加

1. 构造方法：
直接定址，除留余数法，数字分析法，平方取中法，折叠法

2. 冲突处理：
开放定址法（线性探测，平方探测，再散列，伪随机序列）
拉链法（同义词存在同一个链中，方便增删）

3. 性能分析：
散列函数，冲突处理方法，装填因子
### 6.5 串（多几个题练练手）
没啥东西，会算KMP的next数组的值，知道失配后如何移动
KMP适用于子串重合度较高的，不然和基本匹配算法没区别

从0开始的还稍微麻烦一点，从-1开始的很简单
（其实是一样的，都加-1就成了）
要能手动写出这个过程**王道书上的题目会做**

当失配时（默认用-1开头的next数组）
i指向主串的匹配下标，j指向子串的匹配下标
KMP是匹配失败时，i保持不动，j回退到next[j]位置
子串向后滑动位置 Move=j-next[j]
**注意ij下标，有时是从0开始的需要注意**



# 第七章 排序
### 7.1 基本定义
排序的稳定性，内部排序与外部排序（多路归并是外部的）
计算复杂度记住
拓扑排序有时可以算作外部排序
稳定性与算法的优劣无关
### 7.2 插入排序
三种插入排序方式

直接插入与折半插入都是从2-n这些元素插入前面已经排好序的数组中，特点是A[0]不存放元素，折半插入只是在直接插入基础上使用折半查找

希尔排序是将原表先分成子表，在子表内排序
子表数目从n/2 n/4 ··· 1 
在子表内使用的是直接插入排序，因此希尔排序属于插入排序

三种插入排序都是O(n^2),但是只有希尔排序是不稳定的
**插入排序的特点是第n趟排序后前n个元素是有序的**
**题型是计算希尔排序的增量，找到交换位置的两个元素，数下中间间隔几个数+1**
### 7.3 交换排序
有冒泡与快速排序两种，快排是效率最高的O(n*log2n)
冒泡稳定，快排不稳定
冒泡每一趟会将最小的数放到正确的位置上（从后往前的）
**冒泡排序有两种方式，从前往后冒泡，从后向前冒泡**
快排每一次借助枢轴将数组划分为两部分，左边元素都比枢轴元素小，右边元素都比枢轴元素大
**冒泡是从后向前移动的，插入是从前向后的，快排每次分隔为两半**
**快排在基本有序时候效率最低，有n次递归，在每次枢纽元刚好将数组分为两半时候效率最好，有log n次递归**
还要会手写对序列一次快排后的结果序列
### 7.4 选择排序
思路是选择后k-1个元素中最小的那个放在下一个元素位置
堆排序是利用完全二叉树实现，大堆是每个节点数值都大于左右子节点的数值
完全二叉树特性：
左子节点的下标=父节点下标*2+1
右子节点的下标=父节点下标*2+2

每一次建堆可以选出一个最大的元素，与第n个元素交换，再对前n-1个元素建堆选出最大元素，与n-1处元素交换

算法描述：
先对于无序的数组元素建堆
（从n/2个节点向前到第一个节点逐个向下调整）
将堆的根节点A[1]与数组最后一个元素交换
（选出一个最大值放在正确的位置）
再调整堆（将第一个元素向下调整），再交换···

当数组中插入一个新的元素时，使用向上调整方法可以重新实现大根堆
当数组中删除根节点的时候，将末尾数字填入根位置，再向下调整
**堆中某个节点的左右子节点的大小不是固定的，不一定左节点比右结点大，只要子节点比父节点小即可**

**算法不一定让写，但是过程要记得，细心一点**
**构建堆的复杂度O[n],堆排序的复杂度O[nlogn]**
**两种选择排序都是不稳定的**
**仅有简单选择排序这一种基础方法是不稳定的，其他都是复杂方法不稳定，简单方法稳定**
### 7.5 归并排序和基数排序
merge函数是用于将两个子数组归并的，mergesort函数是自身递归的
基数排序也叫桶排序，有三位数就三次放到筒中，三次串成数组
**其实算法理解了，能手动计算模拟过程细心一些就好，这部分比较难的要记住各个排序算法的时空复杂度，稳定性表，以及一些特定计算时各自的特点，方法是记住每一个算法的实现过程，现场思考推演**
### 7.6 内部排序算法的比较
这里是重点考察方向，考察的是对于各种排序算法的理解程度
记忆：就算法思想而言，分为简单排序与复杂排序

简单排序：冒泡排序，直接插入排序，简单选择排序
复杂排序：希尔排序，堆排序，2路归并排序，快速排序
巧妙排序：基数排序

简单排序的时间复杂度都是n^2
复杂排序的平均时间复杂度都是n*logn
巧妙排序的时间复杂度是d*(n+r)
(d是10个桶,r是一次收集)

简单排序只有简单选择排序不是稳定
复杂排序只有2路归并是稳定的
巧妙排序是稳定的

简单排序空间复杂度都是1
复杂排序，快排空间复杂度是logn，2路归并是n
基数排序是r，最坏情况下是n

应用情况：
1. n较小的时候使用直接插入排序或简单排序
2. 基本有序时候采用直接插入排序或者冒泡排序
3. 当要求nlogn时，快排，堆排序，归并
（快排是最好的方法，当关键字随机分布时,平均时间最短
堆排序不会出现快排的最差情况
归并排序空间复杂度是n,但是稳定）
4. 直接插入与冒泡排序最好时间复杂度是n
5. 希尔排序没有时间复杂度

**希尔排序是插入，快排是交换，堆排序是选择**

### 7.7 外部排序
1. 将外存分块读入内存，内部排序
2. 对这些块进行归并

时间=内部排序时间+内部归并时间+外存读写时间
归并趟数=树的高度=log^m^r
(r个初始归并段，m路归并)
要提高外部排序速度：
1. 增大归并路数
2. 减小归并段的个数

外部排序先将磁盘读入内存，在内存中内部排序
（工作区方法生成初始归并段）
（败者树方法实现归并过程）
（最佳归并树实现归并段选择）
