---
layout:     post   				    # 使用的布局（不需要改）
title:      操作系统考研的一点总结 				# 标题 
subtitle:   这是我考研复习时总结的一点知识点 #副标题
date:       2020-04-02 				# 时间
author:     WBY 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 计算机基础
---
# WBY的OS
## 第一章 系统概述
系统调用由OS提供给用户，它不是命令，而是由用户程序间接使用
广义指令就是系统调用命令，shell是命令解析器
系统开机后，系统中的程序将被自动加载到RAM中去

批处理系统是将多道作业一同处理，主要缺点是无交互能力，系统开销大（要组织与管理多道作业），优点是吞吐率大，CPU与IO利用率都比较高

分时系统与实时系统都是为了更快地响应用户
**多任务OS不一定要运行在多CPU的硬件平台上，因为流水可以实现伪并行，但还不算是并行**

**中断与异常：（OS概念）异常是CPU，中断是IO**
软中断与硬中断：（计组）软是CPU内，硬是IO设备
内中断与外中断：（计组）内指的CPU与内存之内

用户调用系统调用（使用访管指令），CPU出现内中断，切换为核心态执行系统调用，执行结束回到用户态

大内核对外只提供接口，功能完备但是复杂
微内核速度快，更稳定，但是在用户与内核态切换频繁，开销较大

用户态与核心态转换是由硬件自动完成的

特权指令：特权指令只在核心态执行
访管指令：在用户态执行，请求切换核心态进行系统调用
中断返回指令：由核心态转回用户态，在核心态执行，是特权指令

IO指令需要在核心态执行
进程切换只能发生在核心态

**内核管理范围**：这些只能够发生在核心态
    时钟管理
    中断管理
    原语
    进程管理，存储器管理，IO管理

广义指令是系统调用命令，这个指令可以在用户态调用，但是执行只能在核心态[区分调用与执行]

**指令中可能导致异常（缺页，除数0等）都有可能导致系统状态的切换**
trap指令可以在用户态执行，关中断指令不能在用户态执行

中断处理是OS必须的，系统调用不是OS必须的
（内核的东西是必须的，用户态以及系统调用不是必须的）

## 第二章 进程管理
### 2.1 进程与线程
需要记住进程状态转换图，知道状态转换的过程
（进程被唤醒是从阻塞态转换到就绪态）

进程三种通信方式：
共享存储：对共享空间进行同步互斥操作
消息传递：两进程通过消息发送与接收传递消息
管道通信：有个缓冲区（文件），同步，互斥，确认对方存在

线程可以提高并发性
多线程模型三种方式，线程在用户与内核空间中三种映射
（与线程的切换相对应）

程序是静态的，进程是动态的
进程是动态的，进程映像是静态的
**进程永远是动态的**

**进程与程序的关联**
程序是永久的，进程是暂时的过程
进程由代码，数据，PCB构成，程序只由代码与数据构成
一段代码多次可以创建不同的多个进程
系统内的一个进程（线程）可通过系统调用的方法被不同的程序多次使用（系统动态库中的同一个系统线程可以被多个不同的进程所调用）

进程调度是从就绪队列中选择一个转换为运行态
正在处理IO操作的进程处于阻塞态
进程的结束有正常结束，异常结束，外界干预
**抠字眼：进程是资源分配的基本单位，线程是资源分派与处理机调度的基本单位**
当一个线程被阻塞之后，内核并不能分清楚，此时整个进程都会被阻塞

PCB中存储的内容是该进程的状态信息，进程的存储信息，进程中剩下的内容存储在代码段与数据段中

### 2.2 处理机调度
发出调度请求，运行调度程序，进程之间切换
（这是三个过程，顺序执行的）

周转时间=作业完成时间-作业提交时间
响应时间=首次响应时间-作业提交时间

调度算法
1. FCFS先来先服务（必定不剥夺）
2. SJF短作业优先（平均等待时间最少，效率最高）
3. 高响应比优先
4. 优先级调度
（系统>用户，交互>非交互，IO>计算型）
**前四个默认非抢占**
5. 时间片轮转（必定剥夺）（使用完时间片后降低优先级）
6. 多级反馈队列（时间片的升级版）

若有IO操作，应当让有IO操作的作业先跑，能充分利用CPU
**这里着重考察对于调度算法的理解，让你选择应当使用的调度算法**

**作业与进程的关系**
作业是用户角度的，由用户提交，以用户任务为单位
进程是OS角度的，由OS生成，是OS资源分配与独立运行的基本单位

**注意不能切换与不能调度，先调度再切换**
进程在临界区可以切换的，但是在内核临界区不能切换
（区别是前一个是资源，如IO设备，后一个是处理机资源）

**画出甘特图表示进程之间的时序关系**
### 2.3 进程同步
#### 2.3.1 进程同步基本概念
进程同步指的是多个进程之间的先后顺序
临界资源一次只能让一个进程使用，资源可以是软件也可以是硬件
由于只有一个资源，多个进程，进程之间使用临界区，进程之间有两种关系：同步与互斥
同步指的是进程之间需要相互等待，传递消息
互斥指的是对于临界区访问必须是互斥的（一次只有一个进程访问临界区）
#### 2.3.2 实现临界区互斥的基本方法
方法分为两种，软件与硬件方法：
软件：（类比几个人上厕所）
    1. 单标志法：咱两交替进（公共的turn）
    2. 双标志法先检查：大家都不进，我就不客气了
    3. 双标志法后检查：我要进，你们还有谁（flag）
    4. 皮特森算法：我想进，但是先给你们用吧
硬件：
    1. 中断屏蔽方法：进程在临界区时，禁止中断发生
    2. 硬件指令方法：不断检查临界区是否为空，一旦空了赶紧上
#### 2.3.3 管程
不是很重要的考点，有下面几个特点需要记忆
1. 管程组成就像一个抽象类
2. 管程内的数据只能由管程内的过程访问
3. **每次只允许一个进程在管程内执行某个内部过程**
#### 2.3.3 信号量
整型信号量的问题：
    未遵循让权等待，会使得进程处于忙等，浪费CPU资源
记录型信号量：
    考的最多的，需要理解（题目中的信号量默认记录型）
```cpp
typedef struct{
    int value;//初始化为资源数目
    struct process *L;//该资源的等待队列
}semaphore;

void wait(semaphore S){
    S.value--;
    if(S.value<0){//说明当前没有资源了
        add this process to S.L;
        block(S.L);
    }
}
void signal(semaphore S){
    S.value++;
    if(S.value<=0){//说明当前还有其他进程在等待队列
        remove a process P from S.L;
        wakeup(p);
    }
}
```
信号量三种关系：
1. 同步（两个进程之间必须先a后b）[信号量初始0]
    a在执行完后wake(b),b在执行之前需要wait(a)
2. 互斥（临界区得互斥地访问）[信号量初始1]
    a与b都是进入临界区之前wait，出临界区之后wake
3. 前驱关系（如那棵树，工程必须按顺序进行）
    对树上每个边初始化一个信号量（都为0）
    按照每条边上都有同步关系设置（入wait，出wake）

解题步骤：
1. 分析关系：几个进程，几个信号量
2. 整理思路：进程之间的互斥同步关系以及顺序
3. 设置信号量
#### 2.3.4 同步的几种问题
四种问题对应四种情况下的解决思路，需要自己搞明白，主要是会做题，遇到问题要从四种情况中选用适合的工具

1. 生产消费者问题
同步关系：满与空两种事件对应两种同步关系
互斥关系：缓冲区需要互斥访问
**难点在于互斥与同步操作的先后顺序，实现互斥的P操作务必在实现同步的p操作之后，不然会死锁**
[先写事件，生产一个产品，在缓冲区中，消费一个产品]
[然后在事件中加入PV操作]
当缓冲区大小是1的时候可以不设置互斥信号量，大于一的时候必须设置

理解时用事件的前后关系去找，不要看单个进程的行为，要使用尽量少的信号量描述清楚进程之间的关系
**互斥关系比较简单，主要是找到同步关系的事件，为其设置前后PV操作**
2. 读者写者问题
有个互斥访问的计数器count
若要实现读写公平，需要给写者增加一个互斥变量

3. 哲学家进餐问题
设一个互斥变量，只有左右两边筷子都可用时，才允许抓起

4. 吸烟者问题
设置int型变量i，i循环增加实现轮流操作

### 2.4 死锁
1. 死锁的四个必要条件：（必须都满足）
    互斥，不剥夺，请求保持，循环等待
（若系统中每类资源都只有一个资源，资源分配图含圈就是死锁的充要条件）

2. 死锁的处理策略
    预防：破坏四个条件中的一个
    避免：银行家算法
    检测与解除：使

3. 死锁预防
    破坏互斥条件：将资源变成共享的
    破坏不剥夺条件：条件不满足，就释放手头所有资源
    破坏请求保持：运行前分配好，运行期间不请求资源
    破坏循环等待：为资源编号，申请大的后不能请求小的

4. 死锁避免
    安全序列能顺利完成，有至少一个安全序列的就是安全状态，安全状态下一定不会发生死锁，不安全状态可能出现死锁（不一定）
    思想是在每一个分配之前都判断是否会进入不安全状态，决定这次是否分配
    算法：
    MAX矩阵-已分配矩阵=可用资源矩阵
    拿手头剩余的资源与可用资源矩阵作对比，找到个安全性的序列
    
5. 死锁检测算法
    依次消除与不阻塞进程（资源分配足够）相连的边，直到无边可消（剩下没有消除的进程就是会导致死锁的进程）
    死锁的解除：
        1. 资源剥夺：挂起某些进程，抢占其资源
        2. 撤销进程：强制撤销某些进程，剥夺所有资源
        3. 进程回退：记录运行状态，回退到能避免死锁的时间点
### 2.5 补充


## 第三章 内存管理
### 3.1 内存管理的概念
1. 程序装入与连接
源程序经过编译之后，变成目标代码，目标代码经过链接与装入，才会变成内存中能够执行的程序
**在链接后形成逻辑地址空间，多个文件链接之前都是0~k1,0~k2···在链接之后，整个逻辑地址空间是0~kn（最终）**
链接三种方式：
    静态链接：在编译时链接
    装入时动态链接：装入内存时链接
    运行时动态链接：在执行时才链接
装入三种方式：
    绝对装入：编译产生的目标代码就是绝对地址
    静态重定位：目标代码是相对地址，装入时重定位
    动态重定位：目标代码是相对地址，运行时重定位
（相对地址是将相对地址加上重定位寄存器的内容到绝对）
（相对地址与逻辑地址一回事,绝对地址与物理地址一回事）
**注意区分与虚拟地址的关系**

2. 内存保护
[CPU在访存时，使用逻辑地址],经过界地址寄存器比较防止越界，再与重定位寄存器相加得到物理地址访问内存

3. 覆盖与交换
覆盖：正在运行的进程不必全部进入内存
    程序分段，固定区常驻内存，覆盖区进行覆盖替换
交换：多个进程之间，将等待状态的移出内存，就绪的移入

### 3.2 内存的分配方式（对应计组中的虚存）
总体分为连续分配与非连续分配
1. 连续分配
    单一连续分配：内存中只有一道程序
    固定分区分配：划分为固定大小的分区，分区内一作业
    动态分区分配：根据进程大小动态建立分区
    **动态分区策略**
    首次适应：（最好）分区按地址递增顺序链接
    最佳适应：（正常思路）分区按容量递增
    最坏适应：（倒着想）容量递减
    邻近适应：从上一次结束处查找

2. 非连续分配
    分页：页定长，页表在内存中（两次访存）
    分段：与页相比就是变长（两次访存）
    段页式：每一段有自己的页表（三次访存）
### 3.3 虚拟内存管理
虚拟存储器直观特点是作业运行之前不必全部装入内存，在运行过程中也不必常驻内存
1. 缺页中断
    在指令执行过程中出现的，属于内部中断
    一条指令执行过程中可能会出现多次缺页中断
    当出现缺页，会将该进程阻塞，从外存中调入

2. 地址变换（特指分页）
    快表是在cache中，相当于页表的cache
    见下面的算法，如果页号就在TLB中，只要访问一次内存，后面两种都要访问两次内存
```cpp
search_address(){
    if(TLB){//如果在TLB中有
        直接将逻辑地址转化为物理地址
        修改TLB中的访问位，修改位
    }
    else(页表){//如果TLB中没有，但主存中有
        在主存中的页表找到物理块号得到物理地址
        修改页表，将页表该表项加入TLB中
    }
    else{//说明不在TLB，也不在页表中，应当在外存中
        将该块调入内存（空了调入，满了替换）
        修改页表，修改TLB
    }
}
```
3. 页面置换算法
OPT：替换未来最长时间不未被访问的页面
FIFO：替换最早进入的页面
（导致Belady异常：增大物理块数，缺页次数反而增加）
LRU：替换最近最长时间未被访问的（要寄存器与硬件支持）
CLOCK：循环查看访问位，找到第一个访问位为1的
改进CLOCK：循环查看访问位与修改位，找到第一个00或01

4. 页面分配策略
给一个进程分配的页框集合是驻留集

驻留集太小：置换率高，利用率大
驻留集太大：当过了限度后，增加驻留集大小对错误率无影响

给每个进程分配驻留集策略：
    固定分配：死板固定
    可变分配全局置换：有缺页分一个
    可变分配局部置换：频繁缺页才分一个

调入页面的时机：
    预凋页：运行前首次调入预测若干调入
    请求调页：运行时，缺页再调入

调入地区：
    全从对换区调入
    不会修改的从文件区，
    未运行过的从文件区，

5. 抖动
刚进来的要调出去，刚出去的要调入（页数太少）

6. 工作集
由工作集窗口与工作时间t决定
会给每个进程分配大于工作集的物理块，减少抖动情况

### 3.4 补充
1. 虚拟内存中，决定虚拟空间大小的是地址线的宽度
2. 虚拟内存管理需要硬件支持，产生缺页中断，由硬件处理
3. 使用交换技术，当进程处于临界区，不能被换出主存
4. 覆盖技术是早期技术，可用于连续分配中的单一连续与固定分区分配
5. 整个系统中只有一个重定位寄存器，由于系统在一个时刻只执行一个程序，所以当程序切换时，将重定位寄存器数值也切换即可，不用为每个程序设置一个重定位寄存器
6. 分段是按照逻辑分段，在用户编程时候就决定了
7. 程序动态链接与程序的结构有关，所以分段存储最利于程序的动态链接
8. 分段，访问外存以段为单位，分页与段页都是以页作为单位（分页在进程中叫页，在内存中叫做页框，外存叫块）
    访问主存都是以字节或者字为单位[cpu不会直接访问外存，而是将页移入内存中访问内存]
9. 分页管理：每个进程一张页表，并且页表必须驻留内存[二级页表不必驻留内存，多级页表的作用就是为了减少页表所占的空间]
10. 内外存的交换，提高速度是主要目标，换区需要CPU参与，使用时间换取空间，若速度太慢，就没有必要使用虚拟内存了，直接让CPU与外存相连吧
11. 二级页表是用几个页a专门存放页表，每一个页a对应一个二级页表b的表项（逻辑空间有几个页，就有几个表项a）

12. 虚拟存储系统的容量不受外存大小决定，而是由地址线或者CPU寻址范围决定
13. [虚拟存储系统只能使用非连续分配管理方法]，内存为进程分配空间才能使用连续分配
14. LRU需要对所有的页进行排序，所以算法实现的耗费较高
15. 页表中合法位决定是否有缺页中断（页表的修改位与访问位是供CLOCK页面算法）
16. 抖动的主要原因是页面置换算法不合理
17. 页面分配与置换策略不能固定分配与局部置换（死板）
18. 工作集大小由时间t与工作集窗口决定[要找t之前的内容]

## 第四章 文件管理
### 4.1 文件系统功能与结构
0. 文件基础概念
文件系统是OS提供给用户的工具，用于直观管理硬盘空间
包含分类与索引，包含用户权限

每个文件信息是一条属性（文件的ID），所有的文件信息存储在目录结构中，目录存储在硬盘中，需要查看文件信息调入内存

对每个打开的文件维护一个数据结构，存有文件的基本信息，存有指针指向文件的上次读写位置，存有当前访问文件的进程数量（数量为0时关闭文件）

1. 文件的逻辑结构（文件内部数据存储方式）
与物理存储无关，是说文件在逻辑上的关联方式
    无结构文件（流氏文件）：一串字符流，无结构
    有结构文件（记录文件）：
        顺序文件：将文件内容组织为记录，记录顺序排列
        索引文件：为文件中记录组织索引表，方便查询
        索引顺序文件：记录分组，为组建立索引
        直接文件：使用散列表存储记录

2. 文件的目录结构（外部多个文件之间的组织关系）
目录每个条目指向对应的文件，包含了文件的属性位置信息
目录存储在外存中,目录的条目有两种形式
    1.FCB：每个条目叫FCB文件控制块
      FCB内容：文件基本信息，存取权限等
      将FCB组织成表，表占的位置较大
      查找文件时，将FCB移入内存

    2.索引节点：用一张索引表，按文件名查找指向文件地址的指针（文件信息只有基本信息，没有权限啥的）
      当文件被打开， 磁盘索引节点导入到内存索引节点，同时增加点内容（状态，访问计数，逻辑设备号等）

目录结构代表文件之间的关系，目录条目之间用什么数据结构存储，文件之间的关系就是与之对应的，对文件创建删除与修改时，同时要修改目录信息
目录结构有三种：
    1. 单级目录结构：整个系统一张目录表，条目顺序排列，使用链表或者数组存储
    2. 两级目录结构：按用户分开，每个用户名下文件是顺序排列的[二维数组],方便区分用户访问权限，不同用户名下的文件能够重名
    3. 多级目录结构：使用树形结构存储，每个叶子结点才是具体文件，从根出发到叶子结点就是文件的路径，[不同文件中能够重名，但查找文件名要逐级访问，影响查询进度]
    4. 无环图目录：实现文件在不同用户之间共享

3. 文件共享
多进程访问同一个文件，但系统只保留一个副本
两种共享方式：
    1. 硬链接（基于索引结点）
    用户文件目录指针指向同一个索引节点，索引节点内部记录指向自己的指针数目count，创建文件时count=1，当有其他指向该文件count++，当count=0，删除文件
    2. 软链接（基于符号链）
    只有创建者的指针指向索引节点，其他访问者都是通过路径名link间接访问，当创建者删除文件，link失效，符号链也删除[通过路径名访问，要多次访问磁盘，开销较大]
    **硬链接速度快，软链接方便网络共享，不用写新的方式，直接给个路径地址就成**

4. 文件保护
文件共享会非法修改文件，需要设置文件访问权限
[1]访问控制
每个文件增加一个访问控制列表ACL，规定用户名与访问权限
ACL长度太长，管理麻烦，改用精简访问列表

精简列表将用户分成三类：拥有者，同组用户，其他用户
在创建文件时写入创建者，创建者所在的组
有用户访问时对比，确定自己的类型，从而知道权限
[2]口令
创建者设置一个口令，并告诉想要告诉的人，要访问文件需要输入口令，不安全
[3]密码
对文件加密，访问需要秘钥，安全但是编码译码有时间开销

5. 补充
设置当前工作目录是为了加快检索时间
（多级目录缺点是访存次数多，实现慢）
OS引入文件系统是为了用户能够按名存取
IO设备视作特殊文件
索引顺序文件分组，组数=文件数目开根号

要读一个文件，Open系统调用打开文件，参数包括路径名与文件名，read系统调用使用open返回的文件参数，不需要文件名，read的参数是缓冲区地址，传送字符数目

相对路径名是从当前目录开始，绝对路径名是从根目录开始

UNIX使用索引节点存储目录结构（不用FCB）

文件保护方法特指文件权限保护
文件被首次打开，需要将FCB内容读入内存中

文件访问限制由用户权限与文件属性决定

**建立软链接，将count的值直接复制，硬链接count++，删除时，软链接count不变，硬链接count--**

### 4.2 文件系统实现
上述是文件系统的功能与结构，具体实现是如何将文件系统在物理存储空间上分布与组织

**对于物理空间管理，记住各种方式的名称与优缺点，想想什么情况适合使用哪种管理方式**

硬盘中文件的分配方式：[文件块管理]
    1. 连续分配：每个文件在磁盘中用一组连续的块存放
    2. 链接分配：（为每个文件分配不连续的空间）
        隐式连接：每个块有个指针指向下一个块，成链
        显式连接：将所有指针存放在一张链接表中，一个指针指向下一个盘块组的地址
    3. 索引分配：每个文件有个索引表，表中以数组形式存放盘块号

文件存储区的空间管理：[空闲块管理]
    1. 存储空间划分：一个文件存储在一个文件卷中
    （文件卷=目录区+文件区）
    2. 空闲块管理：管理未分配的空闲块
        空闲表法：将空闲区组织成表
        空闲链表法：将空闲区组织成链表
        位示图法：磁盘每个盘块对应一个二进制，10满空
        成组链接法：结合表与链表，适用于大型文件系统

？？？访问文件次数？？？

### 4.3 磁盘组织与管理
1. 磁盘的结构
磁盘地址=柱面号+盘面号+扇区号

2. 磁盘一次读写时间计算
一次时间=寻道时间（定磁道）+延迟时间（扇区）+传输时间

3. 磁盘调度算法
FCFS：先来先服务
SSTF：找最近的
Scan：设定一个磁头移动方向
C-Scan：到尾巴后跳跃到开头
Look与C-Look：不必到头尾，找到最后与最前的那个
（默认使用Look与C-Look计算scan与C-scan算法）

4. 磁盘管理
磁盘最开始只是空白盘，格式化后才分区存储数据
    低级格式化：物理分区，划分扇区，扇区内数据结构
    逻辑格式化：创建文件系统，将数据结构存到磁盘上

计算机启动时BIOS自举程序，初始化寄存器，控制器，内存，再将OS内核导入内存，转到起始地址，运行OS

扇区损坏使用某种机制避免使用坏块

文件在一个扇区存不下时，不要放在同一个盘面的不同扇区，而放在不同盘面的同一扇区，省寻道时间+寻扇区时间

5. 补充
磁盘上的文件以块为单位读写，内存中的存储内容以字或者字节为单位读写

磁盘读写时间中影响最大的是寻道时间（寻道时间就是磁盘调度算法用的时间）
