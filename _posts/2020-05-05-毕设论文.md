---
layout:     post   				    # 使用的布局（不需要改）
title:      毕设论文框架 				# 标题 
subtitle:   这是记录毕设论文框架的一篇笔记 #副标题
date:       2020-05-05 				# 时间
author:     WBY 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 开发工具
---
# 话术
我不知道:
    老师您说的这个问题我在做项目的时候也遇到了,当时我查阅了一些资料,也看了项目的源码,但是因为这是师兄他们之前开发的项目,有些文档不太完善,我还是没有理解清楚,谢谢老师的指正,我后面会再跟师兄去交流了解下这个问题

为啥是流程编排:
    我的论文是基于之前的这个服务聚合平台,主要的工作是将一个视频会议的服务注册到这个平台上,并且在平台上实现这个服务与其他服务的聚合,整个的聚合过程是平台的流程编排,我主要做的一些前端的工作

# 答辩稿
尊敬的各位评委老师:下午好！我是来自计算机学院的王博艺,我的毕设论文题目是:轻量级网络编排器的设计
我的论文是在程渤老师的指导下完成的,在此非常感谢程老师对我的精心指导.

下面我将从论文项目背景与论文框架三方面进行我的答辩:
1. 首先是论文背景:...
2. ...
3. 我的论文框架是以此作为依据,由表及里,层层递进地进行论述:
    我的论文的第一部分说明了....
    第二部分说明了....
    第三部分说明了....

本篇论文已经完成,但还有很多不完善的地方,在完成项目与撰写论文的过程中学习了很多知识,积攒了项目开发的经验.我的论文在表述与论证上任存在不当之处,很多问题还有待进一步思考,希望老师能提出宝贵的意见,我会虚心接受,深入学习,提高与完善论文.

我的答辩自述完毕,谢谢各位老师！

# 摘要
随着互联网的飞速发展,人们对于互联网web服务的需求愈发强烈,同时网络基础设施的规模也在持续增长,传统的网络服务架构已经不足以满足现有的需求.为了应对这一趋势,业内涌现出了许多新技术.

网络功能虚拟化（Network Functions Virtualization）便是一种新型的网络架构,这种架构通过软硬件的解耦以及对服务的抽象,使得网络功能设备不依赖于特定的硬件,而能够灵活地部署服务,对资源进行动态调整,从而提升互联网的服务效率,同时减少在运营与维护上的开销,可以实现新服务的快速开发与部署.

本文基于一种新兴的网络服务聚合模型,阐述了轻量级网络编排器中可视化管理系统的设计与实现方案.这种服务聚合模型使用了Node.js,canvas以及WebSocket等前后端技术为用户提供一个基于NFV的微服务架构环境,用户可以通过与可视化界面交互实现服务的链接与部署,使得服务编排操作更加直观.

本文首先介绍了轻量级网络服务编排器的技术背景与意义,描述了网络编排器与前端系统的主要工作.接下来对网络服务聚合模型的架构模式与使用到的微服务技术进行了介绍.在这之后分析了网络编排器为用户提供的应用场景与前端对应的设计,并且描述了前端系统与其他服务子系统的交互方式.在此基础上,本文通过分层的方式重点介绍了各个功能模块的类图,交互方式与工作流程.最后展示了该网络编排器的运行过程与部署情况,对系统进行了联调测试并展示运行结果.

在文章的最后对项目开发过程进行了总结,对于微服务架构等技术进行了展望

# 绪论
## 1. 课题背景与意义
随着网络与通信技术的发展,网络基础设施的种类与规模在不断地增长,出现了物联网与云计算这样的新兴技术,并且在这些新兴技术的基础上发展出了各式各样的网络应用,比如智慧城市/智慧物流/智能家居等,在这样的发展背景下,传统的网络架构面临着巨大的挑战,传统的网络基础设施需要为用户提供更加多样化的服务.然而,传统的网络通常是由多种多样的硬件设备组成的大规模高耦合并且迅速增长的网络架构,每当开发一个新的业务需要增加新的物理设备,同时伴随着设备网络复杂度提升的还有设计,运营以及维护上的巨大开销
除了服务设备需求的高速增长,基于硬件的设备与系统也有生命周期的限制,当硬件设备以及相应的系统到了生命周期,需要重新设计,再次对服务设备进行集成并且在网络上进行部署.然而随着业务迭代的速度越来越快,相应地,基础设施的生命周期也越来越短,这种“设计-集成-部署”的开销越来越大,也变得得不偿失,成为了限制网络服务发展的重要因素,而网络功能虚拟化技术的出现与网络编排概念的提出成为了这一问题的解决方案

网络功能虚拟化（Network Functions Virtualization）旨在将各种类型的网络设备（例如服务器,交换机,存储节点等）构建为一个数据中心网络，通过借用虚拟化技术虚拟化形成虚拟机，然后将传统的业务部署到虚拟机之上。在NFV发展的初级阶段，该技术将作为实施传统业务的新方法，主要实现将传统基于专用硬件的软件执行环境一对一地转化成为基于通用硬件的虚拟机上的专用虚拟化环境。而在NFV发展的高级阶段，NFV将作为实施新业务的新方法，包括将VNF分解为微业务乃至单功能VNF后再重新组合、采用容器技术将单个VM切片成更小容器、应用可软件编程的数据模型实现管理系统集成和自动化管理等过程。

NFV相较于传统网络架构有三个优势:
首先,网络虚拟化技术可以将网络设备的功能从网络硬件中解耦出来,使用通用硬件技术与虚拟化技术代替网络中私有的专业化设备,这样不仅降低了部署新设备的时间开销,也降低了网络硬件设备的造价,将网络硬件设备从专用产品转化为商业化产品,降低项目的开发成本.
其次,这种新型的网络服务架构解除了网络设备控制平面与数据平面的耦合,能够集中网络设备的管理与控制功能,从数据平面上实现可编程操作
最后,通过与网络编排技术的结合可以实现网络服务的快速部署与灵活调整,通过web前后端开发技术能够使得用户在友好的交互界面上实现调度与部署,降低学习成本,提升开发效率

基于这些背景,课题研究了轻量级服务编排器的服务编排与可视化实现.旨在为用户提供一个友好的操作界面,用户可以只通过对操作界面的模块图标进行拖拽就实现对于服务的编排链接,实现服务的部署工作.背后模块的数据通信,工作流程以及业务链的运作由系统自动实现,这样可以减少用户的学习成本与时间开销,并且能够灵活的部署服务,实现对于资源的动态调整,为用户提供直观便捷的开放式工作环境
## 2. 主要研究内容
### 2.0 研究的内容
本次毕设是实现轻量级网络编排器,对服务实现流程的编排,在架构上使用了web前后端分离的技术和框架,这种架构通过可视化界面利用计算机图形学和图像处理技术，将数据转换成图形或图像在屏幕上显示出来，并进行交互处理。可视化的组件比非可视化的组件更好用，更易于维护。当任何一个动态库成了组件，就希望成为可视化的控件，Web服务组件也不例外，通过在项目中加入多媒体会议服务,再实现微服务的流程编排,从而完善项目的功能。
### 2.1 研究的方向与技术
1. 分析业内主流的开发框架与web前后端技术
2. 学习NFV相关的知识搭建NFV环境
2. 研究与设计在Vue框架下实现用户友好的前端交互界面
3. 研究主流的网络虚拟化技术与轻量级网络编排器的设计
### 2.2 研究的具体方法
1. 学习了解微服务架构与服务编排原理
2. 学习掌握微服务的部署,将视频会议服务注册到编排器的服务列表中 
3. 学习JavaScript与HTML5的前端框架,实现微服务的前后端统一
4. 学习整个项目的流程与框架,了解项目的前端架构,在前端增加视频会议服务
5. 实现微服务的流程编排,能与其他微服务联调实现服务的编排
6. 对增加的微服务进行单元测试,根据具体效果进行调整与改进
7. 对整个项目进行联调测试,保证项目的稳定性与健壮性
## 3. 本文结构
本文围绕着网络编排器与可视化管理系统,首先进行了需求分析与流程分析,明确了需要实现的功能,随后对于物联网系统的总体架构与层次划分进行了分析,并且在此基础上对需要实现的功能进行了详细设计与实现,在最后对实现的效果进行了系统测试,观察运行效果.整篇论文的结构如下:

第一章是绪论.在本章中,首先介绍了课题的背景与意义,接着描述了主要研究的技术方向与内容,在最后介绍了本文的组织结构

第二章是对相关技术的介绍.由于使用了前后端分离的web架构,所以将相关的技术分为客户端与服务端进行介绍,其中也包含了web开发中一些新的特性与在项目中的应用.对于每个技术分别从功能,原理以及使用场景三个角度进行介绍

第三章是需求分析.本章描述了网络编排器的使用场景与需求分析,从市场需求的角度对于网络编排器的功能与实现方式进行了分析,最终从项目可行性,需求分析,应用的工作流程三个角度递进阐述了服务聚合模型的合理性与可行性

第四章是模型的层次划分与总体设计,本章中对于服务聚合模型进行了层次划分并介绍各个层次的工作原理,从低到高依次分为物理设备层,资源实体层,服务接口层以及可视化层,在本章的最后介绍了服务流程编排层次划分的设计优势

第五章是功能的详细设计与实现,本章中介绍了此次流程编排中相关功能的实现方式,描述了可拖拽图标的存储与实现方式以及流程编排的过程与实现

第六章是系统测试,通过联调测试对于系统功能进行测试,展示系统的运行情况与实验成果

第七章是对相关技术的总结与展望,本章主要介绍了对该项目成果的总结,介绍了下一步工作的方向与对相关技术的展望

# 相关技术介绍
## 服务器技术
## 1. Node.js
Node.js是在Chrome浏览器的服务端上运行JavaScript的平台,即是在server端上运行解析JavaScript的工具,它能够让后端开发者在服务端运行JavaScript代码.Node.js是对Chrome的V8引擎进行了封装,并一起来创建高性能的服务器以及可拓展的应用程序.node.js有非阻塞，事件驱动I/O等特性，从而让高并发（high concurrency）在的轮询（Polling）和comet构建的应用中成为可能。

在一些传统的服务器中,每当一个客户端向服务端发送链接,服务器需要维持一个连接,每个连接需要一个进程维持,当请求服务的客户端数量很多时,占用内存也会相应的提高,当用户连接数量增长到一定的规模,内存空间会被消耗殆尽.通过非阻塞的服务器接收连接请求,每当一个请求发生时,非阻塞服务器会接收这个请求并且将这个请求传给其他的进程,在这之后响应一个callback,在响应结束后,该非阻塞服务器会继续运行,接收处理其他请求,在这种情况下服务器不会一直等待数据库返回结果,从而节省内存资源,这就是非阻塞的优势.而如果数据库需要将数据返回给客户端,非阻塞服务器就将数据传输给用户的浏览器并且继续运行,在此情况下,服务器的进程不会处在闲等状态,在这种情况下爱,同一时刻的数据库查询数量以及用户的请求数量就没有上限了,服务器只在用户处有时间发生时才会响应,这是事件驱动的优势.

在Node.js中,各个功能的实现是以模块为单位进行划分的,Node.js还有一个专门的模块加载机制,通过该机制我们能够将应用程序划分为若干部分并且能够协同管理这些模块.我们在做工程时将可重复利用的代码写入一个模块中,在任何需要的场合只需要调用这些模块,可以降低工程量,减少代码的重合度,提升工程的效率.
## 2. OpenStack
OpenStack是一个开源的云计算管理平台,他是一系列组件的集合,通过命令或者基于 Web 的可视化控制面板来管理 IaaS 云端的资源池,这个资源池包括了服务器、存储和网络三项.
OpenStack 采用 Python 语言开发，遵循 Apache 开源协议，因此相比 CloudStack 来说，更轻量化，效率更高。OpenStack为私有云和公有云提供可扩展的弹性的云计算服务。项目目标是提供实施简单、可大规模扩展、丰富、标准统一的云计算管理平台。
## 3. WebSocket
WebSocket是一种在单个TCP连接上进行全双工通信的协议。WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。
WebSocket主要是在一个单独的持续性连接上提供全双工与双向的通信.客户端会在JavaScript中创建WebSocket之后发送一个HTTP请求给server用以请求WebSocket连接.在连接建立完成后,该连接会从HTTP协议升级为WebSocket协议.

当前的大多网络是通过轮询的方式实现推送技术.轮询是指在特定的时间间隔内,客户端向服务器发送请求,服务器在接收到请求后就将最新的相关数据返回给客户端的浏览器.这种传统的推送技术会大量占用服务器资源,并且在HTTP协议中的头部长度相较于报文内容占比较大,这样会导致对于带宽等资源的浪费.此外还有通过AJAX技术对轮询进行改进,在该技术中使用Comet技术替代轮询,Comet技术能够实现客户端与服务端的双向通信,但是需要反复发送请求,并且由于Comet使用的长链接,这样会消耗服务器的资源.WebSocket技术能够避免这两个问题,开发者通过WebSocket的接口,客户端与服务器只需要通过一次握手就能够创建一条全双工的数据通路,相较于传统的轮询方式,WebSocket的头文件很小,只有2Bytes大小.另外,在传统的轮询方式中,服务端与客户端的通信是被动的,即只有接收到客户端发送的请求后才能够向客户端回复请求的数据,而在WebSocket中,每当有新的数据产生,服务器会主动将数据推送给客户端.

WebSocket主要有三个优势:
1. WebSocket具有较少的控制开销。每当连接创建后，server和client之间交换数据时，用于协议控制的数据包头部（header）相对较小。在不包含扩展的情况下，对于服务端到浏览器的内容，此头部大小范围在2至10字节之间（具体头部的大小和数据包长度有关）；对于浏览器到服务器的内容，此头部在原报文的基础上还需要加上额外的若干字节的掩码。相较于HTTP请求每次都需要携带完整的头部（header），这种情况下此项头部的开销显著减少了。
2. WebSocket具有更强的实时性。由于协议是全双工（full duplex）的，所以服务器可以随时主动给浏览器下发数据。相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少；即使是和Comet等类似的长轮询比较，其也能在短时间内更多次地传递数据。
3. WebSocket能够保持连接状态。与HTTP不同的是，Websocket需要先创建连接，这就使得其成为一种有状态的协议，之后通信时可以省略部分状态信息。而HTTP请求可能需要在每个请求都携带状态信息（如身份认证等）。

综上对比可知,WebSocket是一项能够实现全双工低延时的实时通信技术,该技术能够明显减少在通信中的时延并且提高系统的吞吐量,随着HTML的发展,WebSocket协议也在进一步完善,WebSocket将会被运用到更多的实时通信场景中.
## 4. REST
REST（Representational State Transfer）是表述性状态传递,是一种软件的架构风格.REST通常基于URL,XML,HTTP等现有的网络协议与标准.表述性状态转移在形式上是一组架构约束的条件与原则.而RESTful则是指满足这些约束条件与原则的应用程序代码.即REST只是一种设计风格而非标准.
在REST的应用程序中,最重要的REST原则是客户端与服务器之间的交互在请求之中是无状态的.这意味着从客户端到服务器的每个请求需要了解该请求的目的,这就需要一些额外的信息负载.这样的优势是客户端发送一个请求,不需要与特定的服务器创建链接,而是任一个可用的服务器在任意时刻都能够响应客户端的请求,这样的交互方式能够使得客户端缓存数据以改进性能.
在server中,将当前的程序运行的功能与状态分为各种资源,每一个资源作为一个概念上的实体对client公开.每个资源通过URL（Universal Resource Identity）得到全网唯一的一个地址.而所有的资源共享统一的界面,从而在server与client之间进行状态的传输.
SOAP（Simple Object Access Protocol）是简单对象访问协议,SOAP常常与简单邮件传输协议,超文本传输协议等通用因特网协议与格式结合使用,所以SOAP具有易于传输的特点,与REST使用JSON格式不同,SOAP是一种基于XML的应用层协议.
相较于REST协议,SOAP具有更高的复杂度.而REST的实现与操作方式更加简洁,是一种轻量级的架构风格.REST不仅能够通过在client的缓存降低响应的时延,也能够完全通过HTTP协议实现,这样的方式使得REST的性能与效率上都比SOAP更优.REST架构对资源的操作包括获取、创建、修改和删除资源的操作正好对应HTTP协议提供的GET、POST、PUT和DELETE方法，这种针对网络应用的设计和开发方式，可以降低开发的复杂性，提高系统的可伸缩性。REST架构尤其适用于完全无状态的CRUD（Create、Read、Update、Delete，创建、读取、更新、删除）操作。
综上考虑,REST是轻量级服务协议,能够更加轻便地实现项目的功能,所以本文的服务聚合模型在架构上采用了RESTful的网络服务.


## 客户端技术
## 1. vue框架
Vue.js是一个JavaScriptMVVM库,是一套用于构建用户界面的渐进式框架,它的主要思想是数据驱动与组件化.Vue相比于传统的Angular.js提供饿了更加简洁并且便于理解的API,使得开发者能够更快速的上手使用.Vue是一套用于构建用户界面的渐进式前端框架,这意味着vue相较于大型框架的不同之处在于可以被设计为自底向上的逐层的应用.Vue的核心库只关注图层界面,使得Vue具有易于上手并且能与第三方库或者已有项目整合的特点.vue框架还能够与现代化的工具链以及其他各种类库结合使用,从而实现为复杂的单页应用提供驱动的功能

Vue的渐进式思想赋予了vue很好地灵活性,相较于传统框架的全面引用方式,vue可以自下而上地通过构建方式引用这个服务库.另外vue是将模块封装为一个个组件,这些组件之间相互独立,组件之间组合成为整个页面,这样的架构方式可以对界面的各个部分进行拆分后的调试与维护.这些组件有各自的模块与数据,组件之间能够嵌套组合,也能够与事件进行连接,每个组件有自己的生命周期与作用范围.vue组件式的开发方式不仅为开发者提供了丰富好用的模板与API,并且便于上手,这符合了本次网络服务编排器的前端界面开发要求,因此在本次项目中是用vue框架作为开发环境.

vue及时响应的特性也为开发者提供了及时的反馈,每当数据模型发生改变时候,函数会及时将修改信息传递给视图界面,视图能够自动更新.

此外vue项目是单页应用，刷新页面会请求一个HTML文件，切换页面的时候，并不会发起新的请求一个HTML文件，只是页面内容发生了变化.单页应用的原理如下:JS感知URL变化，当URL发生变化后，使用JS动态把当前的页面内容清除掉，再把下一个页面的内容挂载到页面上。此时的路由就不是后端实现，而是前端完成，判断页面到底显示哪一个组件，再把以前的组件清除掉使用新的组件。就不会每一次跳转都请求HTML文件。这样的特性不仅方便开发,并且在浏览器请求页面时会减少响应时间,提升用户的使用体验.
## 2. HTML5 canvas
canvas是HTML5的新特性,它可以在HTML中通过JavaScript代码绘制图像.canvas常常被用于制作简单的图画与前端图片,一些复杂的特性与功能甚至可以用于对实时的视频进行渲染与处理.canvas是一个由HTML代码定义高度与宽度属性的可绘制区域,JavaScript代码可以在该区域内绘制相应的图片,通过一些通用的API调用相应的完整绘图函数动态生成图形.

canvas对于简单的图画效果与展示的渲染性能很好,并且使用JavaScript代码绘制图像对于开发者非常友好.canvas中提供了大量的便于开发者调用的图形库,这样便于开发者进行绘制.再通过JavaScript的事件监听的特性,可以捕捉用户对于canvas的鼠标操作,并且与事件绑定,这位前端系统中的实现可拖拽图标,展示界面功能操作提供了技术上的支持.此外,由于JavaScript的与事件绑定的特性,canvas也支持开发者通过JavaScript事件与用户进行数据的交互.

基于以上特性,服务聚合模型的可视化系统采用该技术用于实现可拖拽图标的绘制与界面连线的实现,以便更好地响应用户的实时操作,提供友好的交互界面.
## 5. EJS
EJS（Embedded JavaScript）是一种嵌入式的JavaScript,EJS是Web开发的一种模板引擎.而模板引擎的作用是将用户交互界面与后台开发数据相互隔离,使得开发者专注于对数据的处理而不必关注交互的方式.模板的诞生是为了将显示与数据分离，模板技术多种多样，但其本质是将模板文件和数据通过模板引擎生成最终的HTML代码。模板引擎不只是可以实现代码分离（业务逻辑代专码和用户界面代码），也可以实现数据分离（动态数据与静态数据），还可以实现代码单元共享（代码重用），甚至是多语言、动态页面与静态页面自动均衡（SDE）等等与用户界面可能没有关系的功能。模板引擎的精髓在于可以是程序的界面与数据分离,从而提高代码的可维护性与可重用性,这样能减少重复性的工作,从而能够提升开发的效率.
模板引擎有多种实现方式,最简单的一种是通过置换式模板引擎实现,它是通过替换在内容中的标记实现的.置换式的模板引擎的特点是易于搭建,方便上手,然而在开发过程中利用效率低,很难在高负载的环境下使用,因此也产生了解释型与编译型的模板引擎.
EJS是一种Web模板引擎,具有置换型模板引擎的简明方便的特性,同时也有解释型模板引擎的强大功能.EJS有两种方式构造界面,一种是将数据使用标记的形式在界面中展示,还有一种是通过在HTML中插入JavaScript代码单,通过JavaScript语言构造逻辑,从而构建出页面.由于EJS是在前端页面上使用的,它能保证HTML代码的整洁,主要的优势在于能够将JavaScript与嵌入到HTML界面中,使得开发者专注于界面的开发.在web后端开发时,网页不是静态的,而是有一个固定的动态模板,内部的数据需要通过与数据库或者其他开发模块交互获得.
web后端的服务器收到一个界面请求时,有同步与异步两种顺序处理数据.同步是先读取请求报文,在分析请求后,将HTML与数据一起封装返回发送给用户.而异步方式是只返回一个HTML资源,在HTML中包含JavaScript,JavaScript代码则是在页面载入结束后,通过AJAX访问数据API,并且将获得的内容展示在界面上.同步与异步方式有不同的使用环境,同步方式适用于界面的内容较少,这样的通信方式在发送页面的开销较小.而异步则适用于界面传输的内容较多,这样可以减少实时传输的网络负载开销,从而减轻服务器的负载压力.相比同步,异步的方式需要设计额外的数据接口,接口的性能是用户体验的决定性因素.
而EJS模板引擎选用了同步的方式.在开发过程中,先编写界面的EJS模板,在这一过程中会将HTML的基本结构写入到模板中.服务器在收到前端发送的数据包时,根据数据包的解析内容调用响应的业务逻辑,在这之后使用EJS渲染,通过生成HTML界面作为对前端的响应.综上所述,我们选用EJS实现对于服务聚合模型的快速开发.




# 需求分析
## 1. 可行性
随着物联网与云计算的发展,人们对于web服务的需求越来越多样化,具体化,而在开发web服务的过程中,鉴于服务具有封装性好,服务之间耦合度低的特点,开发者可以将服务封装成一个个的组件,在组件内实现相应的服务,对外提供完善的接口,这样的服务聚合可以降低代码的耦合度,节约开发成本,为开发者提供更多的选择.
在服务需求多样化的同时,人们也需要使用复杂度更高,功能更加完善的服务,此时,单个的web服务难以满足用户的需求,开发者面临的问题是如何将web服务封装并且聚合成为一个提供多样化服务组合的系统.web服务聚合模型的原理就是通过将多种类型的服务组合,为用户提供功能更加强大便捷的综合服务,这使得传统web服务能够在更加多样化的场景中发挥更高价值的作用.为了能够适应多样化的使用场景,开发者需要提高服务的粒度,降低服务之间的耦合性,从而便于用户在相应的场景中快速搭建适合的服务模型.
对于用户而言,服务聚合的部署,组合方式等学习成本较高,所以应当在系统内写出能够自动完成部署的控件,并且为用户提供友好的交互界面.本系统中选用的可拖拽式图标界面,用户只需要通过对图标的拖拽即可完成部署,通过预留的API,可以使用连线的方式完成聚合.这种操作方式简便,便于用户上手,所需的学习成本较低,只需要了解各个模块的功能与相应的参数,而不必关注模块之间的连接方式以及服务的部署情况.这样将轻量级的web服务聚合成为一个系统,并且为用户提供友好的操作界面,这样的开发工具能够降低用户的学习成本,吸引更多用户使用.良好的架构以及低耦合度也降低了系统扩展的成本,为开发者带来了良好的开发体验.
选用的HTML5不仅为交互界面带来了方便的开发工具,例如通过HTML内的拖拽工具实现图标的动态移动.此外,JavaScript也能提升网页的交互能力,为用户带来更好的交互体验.Node.js能够实时渲染界面,canvas能够灵活地绘制界面元素,提高开发的动态性能,Vue便于我们直接在Chrome中以组件的形式进行界面调试.这些都是HTML的优势.
## 2. 需求分析
基于上述可行性分析,我们知道最终的目标是设计一个用户友好的可视化轻量级网络服务聚合模型,并且能够为该模型增加新的服务,与原有服务组合实现服务的流程编排.在可视化界面中,用户可以在服务库中查看服务的类型与大致的功能,也能够在服务聚合窗口自行选择相应的服务进行聚合并获得实时反馈的数据信息.
对于用户而言,系统由三个功能模块组成,分别是服务库,轻量级业务生成环境以及可拖拽数据聚合展示界面.下面分别介绍每个界面的功能.

1. 服务库界面:服务库最大的特点在于内部的服务是可以动态扩展快速开发的,用户能够在服务库中查看并选择相应的服务.每个服务具有封装性好,耦合度低的特点,便于用户自由选择组合.
对于开发者而言,需要将相应的服务封装成组件,对外提供调用的接口,并且规定好组件开发的标准,便于后续的开发者开发出统一标准与接口的服务组件.此外,应当在模型设计之初就设计稳定的架构便于各个组件的增删改操作,使模型便于动态扩展,快速灵活的组合.

2. 轻量级业务生成环境界面:业务生成界面中,各个服务以图标的形式展示在左侧的服务栏中,用户可以自由选择并且用拖拽的形式对图标进行连接,这种方式能够直观方便的展示服务之间的聚合关系.不同组件的聚合接口使用连线的方式进行连接,并且在各自的组件上显示相应的参数,这种直观便捷的方式便于用户选择开发,能够节省学习成本,提高系统的交互能力.

3. 可拖拽的服务聚合展示界面:在该界面上实现了服务对于用户的反馈,服务反馈界面被设计成为纵横顺序排列的形式,用户可以通过拖拽相应的图标,在反馈展示界面上显示服务的信息.这需要通过数据源绑定的形式,与lsce界面上部署好的聚合服务进行绑定,将服务的反馈数据能够实时的在前端界面进行显示.这样的设计能够方便的对于数据源进行选择与绑定,并且能够将后台的数据展示到前台,形成实时反馈.

综上可知,三个界面组合能够为用户提供良好的交互环境,在该环境下,用户可以方便快捷的对服务进行选择与聚合,实时获取后端相应的数据,大大提升开发的效率.
## 3. 应用流程
开发者首先在服务库的可视化界面LSCE中创建具有相应功能的服务,并且通过流程编排确定服务与其他服务之间的聚合方式.用户在了解自己的需求后,根据各个服务的大致功能订制适合应用环境的聚合服务.在LSCE界面中,以服务列表的形式展示服务库中已经注册的服务.用户根据订制的聚合服务模型查找相应的服务,并且通过点击与拖拽相应图标,可以在空白的界面上实现聚合服务的自动连接与部署.用户只需要关注聚合服务中子服务之间的聚合关系,系统后台会自动实现底层的数据交互以及服务内部的流程运行.用户在部署运行之后,用户能够在PIZZZAHUB界面查看各个服务的运行情况,在该界面中,影虎能够依据已知的服务,在服务列表中选择相应的服务并且与特定的数据源进行绑定,服务的窗口能够从服务库中内部的模板,后台程序利用Node.js获取相应数据,实时传给交互界面进行及时反馈


# 模型层次划分与总体设计
## 0. 层次划分方法
该流程编排服务聚合模型自顶向下划分为四个层次,分别是可视化接口层,服务接口层,资源实体层以及最底层的物理设备层.最顶层的可视化设计层是通过调用restful的接口与下一层的服务接口进行通信,通过服务接口层提供的restAPI调用完成功能,并且将底层的一些相关参数展示到用户交互界面上,为用户展示数据处理后的展示结果.服务接口层将底层的资源实体层进行封装,对上层的可视化层提供API接口,即服务接口与资源实体是对服务进行抽象与封装,资源实体主要作用是对物理层的数据与设备进行格式转化,转化为后台数据库中的相应数据,这样可以对上层隐藏硬件模型,抽象为数据与服务的模型.物理层是将物理设备封装为资源实体并接入系统中.
## 1. 物理设备层
物理设备层（Physical Layer）可以接入物理设备,比如一些传感器,摄像头等电子设备,这些电子设施作为数据采集器,在物理设备层接入系统,为上层提供相应的数据.物理设备层的设备对外展示两个属性UID与interface,其中的UID是每个设备的标识,用于标记物理实体的ID,interface是该设备采集的数据的格式,作为向上提供数据的接口.
## 2. 资源实体层
资源实体层（Entity Layer）对物理设备层的设施进行封装,将每个数据采集器的interface包装成统一的格式,便于上层对数据进行相应的处理.除了保留了Physical Layer设备的UID,它还扩展了entityname,Prototype service以及src对设备的信息与提供的服务进行描述.其中的UID保留了物理层的信息,用于标识区分设备,Prototype service是对设备提供的服务进行划分.
此外,它将设备的interface内部也细分为了多种属性,这些子属性描述了实体的信息,实现了封装,对上层只提供封装后的信息,不必管理物理层设备的细节.
资源实体层为了实现对上层的抽象,需要将差别很大物理设备封装成为格式一致的资源实体,由于各个设备的使用背景与数据格式种类很多,不利于上层对这些数据进行封装统一处理,需要设定统一的标准,方便在服务接口层编程.在对物理设备进行封装的同时,传输协议也有较大差别,不同设备的通信方式与通信标准不同,对数据的传输标准与传输格式也不同,会有多种传输渠道例如网线,蓝牙,无线网络等,为了便于处理,在Entity Layer中统一转化为http协议进行传输.
总结资源实体层的功能就是在硬件层与服务接口层起到过度与封装的作用,对数据格式的处理也是在这一层进行,上层的服务接口层不与物理层直接通信,而是使用封装后的数据与接口,调用虚拟设备,以资源实体的视角管理设备.
## 3. 服务接口层
服务接口层是真正的后端服务层,所有服务对用户提供的功能在该层实现.服务接口层与上层的可视化设计层相连,作为中间层一方面对资源实体层的数据进行处理,一方面实现功能,并且以restful接口的方式对上层提供相应的服务.在服务接口层,平台将每个服务封装为组件,这样可以降低服务之间的耦合度,便于服务之间独立实现各自的功能.
每个服务组件是一个service model的形式,也通过使用封装的形式对外提供服务接口,每个service的属性有名称,类型,接口与信息.名称（name）是每个服务的ID,用于标识服务,起到ID的作用.类型则是将服务按照功能分为若干大类,在之后的服务链的组合时可以通过类型进行分类与组装,另外分类也便于开发者对于服务库的分类管理,每当开发一个新的服务加入服务库中,通过分类能够更好地定位与管理.Info则是服务的信息,通过info内的属性能够更好地描述服务的状态与功能.info中的信息会在可视化层中进行展示,是前端交互的一些参数,例如服务标题,服务图标等等,这些信息中有的能根据后端的数据进行实时改变,并且动态呈现到前端中,用以展示服务的工作状态.
服务接口层也是对资源实体层的封装,通过编写相应的功能并同时调用资源实体层的数据接口,并将数据与功能逻辑封装为服务组件,每个服务组件通过restful接口与其他组件进行通信.服务组件也通过rest接口对上层提供服务的调用.
## 4. 可视化设计层
可视化设计层是与用户交互的界面,将服务以服务库的形式展示.用户可以在服务库中拖拽选择相应的服务,并且在pizzahub界面选择资源实体进行绑定.在pizza界面展示服务的实时运行过程,展示数据的运行结果.可视化数据层采用了node.js等前后端技术,解决了动态渲染的问题,能够与用户进行实时交互,减少了前端的渲染工作,在后端完成再发送给前端.可视化层是与用户直接交互的层,能够与用户实现友好的交互,使用户通过简单的方式调用设计出业务逻辑,减少开发学习成本.
## 5. 服务流程编排的优势
流程编排可以动态的将新服务加到已有的服务聚合平台上.主要有下面几个优势:
1. 轻量级
    模型是将提供服务的物理设备部署在本地上,利用设备的计算能力实现相应的功能,而设备之间则是通过restful接口进行通信,因此该服务聚合平台具有轻量级的特点.
2. 开发成本低
    每当需要产生新的业务需求,用户只需将服务库中相关功能的服务进行组合,通过简单配置,用户能够轻松实现对应环境下的业务,而开发者能够动态扩充服务库,增加服务库中的服务模型,为用户提供更多的选择.
3. 灵活度高,耦合性低
    服务库中的服务在可视化界面的展现,在内部是通过调用服务接口层提供的restAPI实现的,各个服务是被封装为组件的形式,服务与服务的耦合度低,只通过API实现流程的编排,能够更加灵活的实现服务的配置.

# 详细设计与实现
## 1. vue框架
## 2. LSCE界面
## 2. 组件拖拽的实现
## 4. 流程图的连线设计
## 5. 服务编排的设计

# 系统测试

# 总结与展望
## 1. 工作总结
本文主要基于已有的轻量级网络服务聚合模型进行说明与设计,从市场的背景开始,从可行性的角度对于模型进行了需求分析,论证了项目的可行性与实用性.接下来介绍了项目中使用到的技术,从技术的背景分析说明了选择这些背景的原因,并且使用了对比的方式将web开发的新技术与传统技术的优劣进行了详细的分析.在这之后又从用户的角度分析了可视化界面的设计目标与工作流程.接下来进行了模型的分层分析,自底向上的介绍了各个层次的流程与实现的原理,为接下来的详细设计提供了理论的框架.在详细设计中具体分析了在可视化界面上做的工作与服务在流程上的编排工作.
在撰写毕设论文的过程中,我查阅了很多资料,阅读了相关技术的文档,学习到了本次项目使用的一些新兴技术的背景与使用的情景,也从底层开始,对于整个项目的架构有了较为深入的了解,提升了我在项目开发中的经验,学习了软件开发的相关流程与工作原理,跟导师以及学长学姐的交流开拓了我的眼界,让我明确了下一步的研究方向.
## 2. 下一步研究工作
该服务聚合模型已经有了较为完备的大体架构,下一步的工作需要完善服务库的服务组件,建立一个统一的开发标准,以便能够快速的新建服务组件并且进行开发.此外,考虑到该模型可能运行在高负载高并发的服务环境下,这需要学习一些新兴的技术,不断完善服务聚合模型,使该模型能够拥有更广阔的适用范围与更加庞大的适用人群.

# 参考文献

# 致谢